# day1

## java8新特性

```java
//一个java文件中，可以包含多个类，类之间没有包含关系，不是内部类
class T{

}
public class Demo {
}

接口的实现：通过匿名内部类进行的实现，

        Sum s = new Sum() {
//            方法存在于类中------》没有名字的类 匿名类
//            类存在于另一个类中-----》内部类
//            ========》匿名内部类
//            =======》只要再java中有类，一定被编译class文件
//            Demo$数字.class
            @Override
            public int add(int a, int b) {
                return a+b;
            }
        };
        s.add(100,10 );
匿名内部类可以对接口进行实现， 接口中的方法可以有多个，
匿名内部类也可以对抽象类进行实现，抽象类中也可以有多个方法

匿名内部类可以实现接口，但是，
    形成新的类，编译时间，
    new 代码比较复杂，
    形成新的文件，占用硬盘空间

lambda表达式=========》简洁
    lambda表达式的要求：只能对接口进行实现，接口中只能有一个抽象方法
    
    （接口中只能有一个抽象方法，但是可以有多个普通方法）
    接口中jdk1.8可以有普通方法，加defalut关键词，
    如果以后类实现了接口，不强制实现类重写方法，方法可能是普通方法
    public default void test(){
        
    }
	接口中jdk1.8可以有静态方法，加static关键词，
    public static void test1(){
        
    }

	lambda表达式书写规则
//         要实现的方法的参数  指向   实现的方法的逻辑
//        (参数列表)          ->   {方法体}
    方法对有参有返回值方法的实现：
    	接口中的方法：
    	public interface Sum {
		   int add(int a,int b);
		}
	方法实现：
        Sum s = (int n,int m)->{return n+m;};
        int add = s.add(100, 100);
        System.out.println(add);

    方法对有参无返回值方法的实现：
        接口中的方法
      public interface Sum {
        void add(int a,int b);
    }  
    方法的实现：
        Sum s = (int a,int b)->{
          System.out.println(a+b);
      };
      s.add(100,10 );
   方法对无参有返回值方法的实现： 
       接口中的方法：
	public interface Sum {
        int add();
    }
	方法的实现：
        Sum s = ()->{return 100;};
        System.out.println(s.add());
	方法对无参无返回值方法的实现：
        接口中的方法
        public interface Sum {
            void add();
        }
	方法的实现：
         Sum s = ()->{
            System.out.println("fd");
        };
        s.add();

lambda表达式比匿名内部类简简洁，还有自己的简化规则
 	形参部分可以省略：
    	参数的数据类型可以省略
    
    1 如果要实现的方法是无参的，小括号不能省略
    2 如果要实现的方法是有参的只有一个参数，数据类型可以省略并且（）也可以省略
    3 如果要实现的方法是有多个参数的，数据类型可以省略（如果要省略，所有参数的类型都省略，
    如果不省略，所有的都不省略），但是（）不能省略

    方法体逻辑可以省略：
    	如果方法的逻辑只有一句代码，{}可以省略的
    	方法有返回值
    		如果方法的逻辑只有一句代码，return省略后，{}可以省略的
    	方法无返回值
    		如果方法的逻辑只有一句代码，{}可以省略的
     方法对有参有返回值方法的实现：
    	接口中的方法：
    	public interface Sum {
		   int add(int a,int b);
		}
	方法实现：
        Sum s = (int n,int m)->{return n+m;};
        int add = s.add(100, 100);
        System.out.println(add);

	lambda表达式省略后的书写规则：	
	 	Sum s = (a,b)->a+b;
        System.out.println(s.add(100,300 ));	

	方法对有参无返回值方法的实现：
        接口中的方法
      public interface Sum {
        void add(int a,int b);
    }  
    方法的实现：
        Sum s = (int a,int b)->{
          System.out.println(a+b);
      };
      s.add(100,10 );

lambda表达式省略后的书写规则：	
	Sum s = (a,b)-> System.out.println(a+b);
    s.add(100,200 );
======================》进行简化

```

## 方法的引用

```java
注意：要实现的接口的方法的参数和调用的方法的参数保持一致（数据类型和参数个数）
    
方法实现的逻辑不在lambda表达式中直接书写，而是要进行其他方法调用，实现逻辑

1 静态方法：类名.方法名（） 
   接口中的方法：
    	public interface Sum {
		   int add(int a,int b);
		}

//求和的逻辑定义成一个静态方法---------》实现逻辑的方法
public class NumAdd {
    public static int sum(int a,int b){
        return a+b;
    }
}

 通过调用静态方法，进行了逻辑实现：
      Sum s = (a,b)->{
           return (NumAdd.sum(a, b));
        };
        s.add(100, 200);

 进行静态方法引用：
     格式：类名::方法名
         
    方法实现：
     Sum s = NumAdd::sum;
     System.out.println(s.add(100, 200));;
    
	Sum s1 = Integer::sum;
    System.out.println(s.add(200,600 ));
	效果是一致的--------------------------------》

  进行实例方法的引用：
        书写格式：new 对象::实现方法
        接口中的方法：
        public interface UpperTest {
            String upper(String s);
        }
	实例方法的书写：
        public class UpperUtil {
            public String change(String s){
                String result="";
                for (char c:s.toCharArray()
                     ) {
                    result+=(char)(c-32);
                }
                return result;

            }
        }
	方法实现：
         UpperTest t = (String str)->{return new UpperUtil().change(str);};
		最简洁的lambda表达式
         UpperTest t = str->new UpperUtil().change(str);
		实例方法引用：
             UpperTest t = new UpperUtil()::change;
       		 System.out.println(t.upper("abc"));

类对实例方法的引用：
    书写格式：类名：：实例方法
    
    接口中的方法
    public interface UpperTest {
        String upper(String s);
    }
	方法实现
		public class UpperUtil {
            public String change(String s){
                String result="";
                for (char c:s.toCharArray()
                     ) {
                    result+=(char)(c-32);
                }
                return result;

            }
        }
	接口中的方法，其实再参数类型String类中也有相应的逻辑，要实现的方法的参数正好就是String类型
    实现的逻辑，再参数类型所在的类中有方法，可以通过类引用实例方法  
        
    UpperTest t1 = String::toUpperCase;
    System.out.println(t1.upper("fdjfkdjf"));

构造方法引用：
    书写格式：类名::new
        
    接口中的方法：
    public interface CreateCat {
        Cat cre();
    }
	类的书写：
	public class Cat {
        private String name;
        private Integer age;
        private String type;
        public Cat() {
        }
         public Cat(String name, Integer age, String type) {
            this.name = name;
            this.age = age;
            this.type = type;
        }

    }

	实现方式：
        CreateCat cat = ()->{return  new Cat();};
	lambda表达式的简化书写：
        CreateCat cat = (name,age,type)->  new Cat(name,age,type);
	 	CreateCat cat =Cat::new;
        System.out.println(cat.cre("tomcat",1,"加菲猫"));

数组引用：
    书写规则：
    	数据类型[]::new
	接口中方法的定义：
    public interface CreateArr {
        int[] cre(int length);
    }
	方法现实：
         CreateArr arr = (int length)->{return new int[length];};
	lambda表达式简洁书写：
        CreateArr arr = length-> new int[length];
	数组引用：
          CreateArr arr = int[]::new;
        System.out.println(arr.cre(10));

```

## 常用的接口

```java
进行条件判断的接口：
    test就是进行判断
    and 并且，两个条件是否同时成立
    or 或者 两个条件是否有一个条件成立
    negate 取反
Predicate<Integer> pre = new Predicate<Integer>() {
            @Override
            public boolean test(Integer integer) {
                return false;
            }
        };
        Predicate<Integer> pre1= a-> a>90;
        System.out.println(pre1.test(100));
        System.out.println(pre1.negate().test(100));

        System.out.println(pre1.and((s)->s>10).test(50));
        System.out.println(pre1.or(s->s>10).test(50));

比较接口：
    Comparator<Integer> com = new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1-o2;
            }
        };
        Comparator<Integer> com1 = (a,b)->a-b;
        System.out.println(com.compare(10, 20));
        System.out.println(com1.compare(10, 20));

类型转换的接口：
    Function<Integer,String> fun = new Function<Integer, String>() {
            @Override
            public String apply(Integer integer) {
                return integer.toString();
            }
        };
        Function<Integer,String> fun1 = a->a.toString();
        System.out.println(fun1.apply(1) instanceof String);
```

## 函数式编程（通过stream流实现）

```java
函数：
	例如：excel表 ，成绩表，排序，排序 升序，降序
				  求和，平均成绩
				  筛选功能
	-------------------》对应的函数，完成对应的功能
	函数书写逻辑我们不关心，关心得是能实现得功能----------》

    java中函数，通过函数进行功能得实现，通过stream流实现得

    创建出stream流得对象
    	创建方法叫做开始流：
    	lists.stream()；
    	Stream.of() 
    
    对stream流进行操作，中间流（中间流可以有多个）
    
     for (Integer i:lists
             ) {
            if (i>150){
                System.out.println(i);
            }
        }
lists.stream().filter(new Predicate<Integer>() {
            @Override
            public boolean test(Integer integer) {
                return integer>=100;
            }
        }).forEach(System.out::println);
        System.out.println("==========");
        lists.stream().filter(i->i>=100).distinct().sorted(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return -(o1-o2);
            }
        }).forEach(System.out::println);

        lists.stream().filter(i->i>=100).distinct().sorted((a,b)->-(a-b)).forEach(System.out::println);


	//      fliter方法，根据条件进行数据得过滤
     lists.stream().filter(a -> a > 150).forEach(System.out::println);
	//      distinct方法，数据进行去重
 	lists.stream().filter(a -> a > 150).distinct().forEach(System.out::println);
	//      sorted 进行排序，默认升序
	lists.stream().filter(a -> a > 150).distinct().sorted().forEach(System.out::println);
	//     sorted排序，指定排序规则
	  lists.stream().filter(a -> a > 150).distinct().sorted((a,b)->-(a-b)).forEach(System.out::println);
	//     limit() 限制数据得显示
	stream.limit(3)
    // max() 最大值
        stream.max(((o1, o2) -> o1-o2))
    //min() 最小值
        stream.min((o1, o2) -> o1-o2)
        
     数据类型转换，可以转成指定得类型
        /* stream.map(new Function<Integer, String>() {
            @Override
            public String apply(Integer integer) {
                return integer.toString();
            }
        }).forEach(System.out::println);*/


       stream.map(new Function<Integer, Cat>() {
           @Override
           public Cat apply(Integer integer) {
               return new Cat("abc", integer);
           }
       }).forEach(System.out::println);

	简化：
         stream.map(o->new Cat("abc",o )).forEach(System.out::println);
	转成指定得类型
        stream.mapToDouble(new ToDoubleFunction<Integer>() {
            @Override
            public double applyAsDouble(Integer value) {
                return value.doubleValue();
            }
        }).forEach(System.out::println);===========》double
        mapToInt() int类型
        mapToLong() long类型

	stream结束流得方法（流结束了，不能再进行方法得调用）
        count() 结束
        foreach（） 
        get() 获取数据值
        判断整个集合中得数据得大小
        boolean b = stream.allMatch(o1 -> o1 >=1);
	count方法进行计数
	Stream<Integer> stream = lists.stream();
    long count = stream.count();
	拿到得数据得结果进行保存：
        toArray(); 实现数组存储
```

# day2

## 新特性

```java
动态参数（可变长参数）
	参数得个数，可以传入任意个，但是实际已数组得方式进行得存储
动态参数位置得要求：
	放到方法得末尾

字母常量：
	int b = 1_0_0_0_0_0_0_0;
        System.out.println(b);
static 静态导入
    import static com.bjpowernode.test2.Test.*;
	导入类中得静态方法，进行方法调用，可以不写类名
```

## 数据库引出

```java
写管理系统，数据得存储，java中得对象进行存储到硬盘上=========》对象流ObjectInputStream
对象进行序列化写到硬盘上，不方便：
	1 打开文件进行文件内容得查看，字节码（字节相关特殊符号），-----》可读性差
    2 修改不方便，存储得字节，字节有自己得存储规则，不能手动进行修改，程序中修改
    3 数据添加，只能再程序中添加
-------------------》
    
    java对象进行存储（硬盘上存储），
    	可读性高，供我们进行数据得操作
		=================================》使用数据库，弥补以上字节流存储得缺点
    
数据库得作用：进行数据得存储    
```

## 数据库分类

```mysql
1 关系型数据库
	通过行列关系进行数据得存放
	类似于excel表，通过一行表示一条数据，一列表示一个特征上得值
	
	sqlserver：关系型数据库，只能运行在windows系统上，例如：医院挂号系统
	oracle：关系型数据库，可以运行在不同得系统上，windows，linux，强大，各种函数
			收费得，费用不低，--------》=======》使用少
	mysql：关系型数据库，可以运行在不同得系统上，windows，linux，功能没有oracle强大
			免费，一台mysql得服务器性能相对低，mysql搭建集群（多台）
		===========》mysql安装，按照笔记安装即可
		mysql卸载比较麻烦，其他得软件不同，如果卸载需要清理注册表，否则数据库不能安装
			
2 非关系型数据库
	不是通过行列进行得数据存放
	1 redis （后面有相关课程）
		通过key-value进行得数据存储
	2 mongoDB 非关系
		json（放一放）
```

## mysql数据库

```mysql
1 java----》jdk，桌面上没有快捷方式
2 mysql ---》没有快捷方式，查看mysql安装成功，电脑上以服务得方式存在

使用mysql得服务？
服务：
	聊天室
```



```mysql
mysql是一个服务，需要有一个客户端，再客户端中进行信息得指定格式得输入，通过服务端进行相应处理

服务一定有自己运行得电脑，ip：本机127.0.0.1，端口号port：3306
安装：密码安装时需要自己设置，使用mysql需要输入密码进行登录到服务
     mysql默认得用户名：root

mysql使用，必须有客户端，通过客户端进行操作，
	需要输入对应得信息，用户名和密码，ip+port才能进行使用
	
mysql内置了一个命令行得客户端，可以再命令行中进行相关信息得输入
	命令行中密码输入错误，闪退
	
命令行中遵循mysql得规则，进行命令得输入：
	mysql 数据库，
		一个mysql得服务下，可以存储多个数据库，一个数据库中不能存储数据，
		数据库中存放多个数据表，数据表中进行数据得存储
		类似于文件夹和文件得关系，文件夹中不能直接存数据，文件存储数据
		
	mysql数据库自带系统得数据库文件，文件不能动
常用得命令：
	mysql服务中包含得数据库列表：
	mysql> show databases;
    +--------------------+
    | Database           |
    +--------------------+
    | information_schema |
    | mysql              |
    | performance_schema |
    | test               |
    +--------------------+
    4 rows in set (0.01 sec)
    
	创建 数据库  名字   
	create database 名  
    mysql> create database d1
        -> ;
    Query OK, 1 row affected (0.00 sec)
    
    mysql> create database d1;
	ERROR 1007 (HY000): Can't create database 'd1'; database exists  '
	进行命令执行，java异常机制，如果出错进行相应得提醒，如果正确，正常执行
	
	命令行执行过程：
```

![无标题](C:\Users\Tly\Desktop\无标题.png)

```mysql
指定使用哪个数据库，指定哪个数据库，就是再哪个数据库下进行表得创建
	use 数据库名字
	mysql> use d1;
	Database changed

当前数据库下创建表，创建表时，一定要指定表中有几个列，每个列上有自己得数据类型
	create table 表名(列名 数据类型,列名 数据类型。。。。。。。。。。)
    mysql> create table cat;
    ERROR 1113 (42000): A table must have at least 1 column
    	
    mysql> create table cat(name varchar(16),age int ,type varchar(16) );
    Query OK, 0 rows affected (0.03 sec)
	
查看当前数据库下所有数据表得列表
	mysql> show tables;
    +--------------+
    | Tables_in_d1 |
    +--------------+
    | cat          |
    +--------------+
    1 row in set (0.00 sec)
查看表中列得信息，列名和列上得数据类型
	mysql> describe cat;
    +-------+-------------+------+-----+---------+-------+
    | Field | Type        | Null | Key | Default | Extra |
    +-------+-------------+------+-----+---------+-------+
    | name  | varchar(16) | YES  |     | NULL    |       |
    | age   | int(11)     | YES  |     | NULL    |       |
    | type  | varchar(16) | YES  |     | NULL    |       |
    +-------+-------------+------+-----+---------+-------+
    3 rows in set (0.01 sec)
	简化：
	mysql> desc cat;
    +-------+-------------+------+-----+---------+-------+
    | Field | Type        | Null | Key | Default | Extra |
    +-------+-------------+------+-----+---------+-------+
    | name  | varchar(16) | YES  |     | NULL    |       |
    | age   | int(11)     | YES  |     | NULL    |       |
    | type  | varchar(16) | YES  |     | NULL    |       |
    +-------+-------------+------+-----+---------+-------+
    3 rows in set (0.01 sec)	

对表中得数据进行操作，
	添加数据到表中-----》插入
	插入时，值得顺序和表中得列得顺序保持一致
	mysql> insert into cat values("tomcat",2,'jiafeimao');
	Query OK, 1 row affected (0.01 sec)
    mysql> insert into cat values(2,"tomcat","jiafeimao");
    ERROR 1366 (HY000): Incorrect integer value: 'tomcat' for column 'age' at row 1
	不知道每个列上得值，
	插入时，值得个数和列得个数保持一致
	mysql> insert into cat values(2,"jiafeimao");
	ERROR 1136 (21S01): Column count doesn't match value count at row 1 '

	插入时，可以指定要插入得列名是什么
	mysql> insert into cat(age,type) values(3,"lanmao");
	Query OK, 1 row affected (0.00 sec)
==============================================》以后进行数据插入，一般使用这个方式
===================================》插入数据时，表名后加列名，即使是全表插入也加列名

	插入时，没有给name列上输入值，默认得值，NULL
	mysql> select name,age,type from cat;
    +--------+------+-----------+
    | name   | age  | type      |
    +--------+------+-----------+
    | tomcat |    2 | jiafeimao |
    | NULL   |    3 | lanmao    |
    +--------+------+-----------+
    2 rows in set (0.00 sec)
    
    mysql进行输入插入，支持批量插入，同时插入多条数据，不知道得数据，使用null进行占位
    mysql> insert into cat(name,age,type) values("abcd",5,"jiamao"),
    ("aaa",1,NULL),("bc",NULL,"lanmao");
    Query OK, 3 rows affected (0.01 sec)============》
    Records: 3  Duplicates: 0  Warnings: 0
    
	mysql> select name,age,type from cat;
    +--------+------+-----------+
    | name   | age  | type      |
    +--------+------+-----------+
    | tomcat |    2 | jiafeimao |
    | NULL   |    3 | lanmao    |
    | abcd   |    5 | jiamao    |
    | aaa    |    1 | NULL      |
    | bc     | NULL | lanmao    |======>数据存储，以行列进行的存放
    +--------+------+-----------+
    5 rows in set (0.00 sec)
	插入时手动写的null和默认填充的null两个是一样的

查看表中得已经存在得数据：
	select 列名，列名。。。。。 from 表名
	select * 所有列 from 表名
    mysql> select name,age,type from cat;
    +--------+------+-----------+
    | name   | age  | type      |
    +--------+------+-----------+
    | tomcat |    2 | jiafeimao |
    +--------+------+-----------+
    1 row in set (0.00 sec)

```

# day3

```mysql
数据的修改
更新表中已有的数据
update 表名 set 列名=值
mysql> update cat set age=3;
Query OK, 4 rows affected (0.01 sec)
Rows matched: 5  Changed: 4  Warnings: 0
注意：以后只要进行修改，一定要指定条件，指定修改的数据是哪一条
例如：	
	用户：20万，密码 修改，-----====》

条件指定：where
update 表名 set 列名=值，列名=值，。。。。where 条件指定

mysql> update cat set age=5 where name='abcd';
Query OK, 1 row affected (0.01 sec)--------------》
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from cat;
    +--------+------+-----------+
    | name   | age  | type      |
    +--------+------+-----------+
    | tomcat |    2 | jiafeimao |
    | NULL   |    3 | lanmao    |
    | abcd   |    5 | jiamao    |
    | aaa    |    3 | NULL      |
    | bc     | NULL | lanmao    |
    +--------+------+-----------+
    5 rows in set (0.00 sec)
    
数据删除-----------》只要以后写删除，必须加条件
	delete from 表名 
mysql> delete from cat where age=2;
Query OK, 1 row affected (0.00 sec)-------------》

--------》以后进行表中数据的修改和删除，一定要指定条件

数据库专门对数据进行的操作，提供了对应的语句，完成表中数据的操作----》相对而言，可读性高
数据库中，进行增删改，结果是受影响的行数
		进行查询，结果是一个结果的表
```

## mysql数据类型

```mysql
一个语言
	sql：结构化 structrue 查询 query 语言 language
	命令---》sql语句

创建表时，表中进行数据的存储，每个列上都有自己的数据类型  varchar 字符串  int 数字
数据类型：
	java中的数据类型，数字类型，字符串类型，日期类型
	数字类型：byte  范围-128到127
	java数字类型					mysql数字类型
	byte                              tinyint    范围一致 -128到127
	short                             smallint    -32768到32767
									  mediumint   (三个字节)
	int								  int--------》
	long                              bigint------》
	
	float							  float
	double							  double--------》
	BigDecimal 					      decimal-------》
	
	
	tinyint数据类型：
	mysql> create table test1(name varchar(16),age tinyint);
	Query OK, 0 rows affected (0.02 sec)
	mysql> insert into test1(name,age) values("abcd",-128);
    Query OK, 1 row affected (0.00 sec)

    mysql> insert into test1(name,age) values("abcd",127);
    Query OK, 1 row affected (0.00 sec)

    mysql> insert into test1(name,age) values("abcd",128);
    ERROR 1264 (22003): Out of range value for column 'age' at row 1
    mysql> insert into test1(name,age) values("abcd",-129);
    ERROR 1264 (22003): Out of range value for column 'age' at row 1
    
	smallint数据类型：
	mysql> insert into test2(name,age) values("abcd",-32768);
    Query OK, 1 row affected (0.01 sec)

    mysql> insert into test2(name,age) values("abcd",32767);
    Query OK, 1 row affected (0.01 sec)

    mysql> insert into test2(name,age) values("abcd",32768);
    ERROR 1264 (22003): Out of range value for column 'age' at row 1
    mysql> insert into test2(name,age) values("abcd",-32769);
    ERROR 1264 (22003): Out of range value for column 'age' at row 1
	int数据类型：
	mysql> create table test3(name varchar(16),age int);
    Query OK, 0 rows affected (0.02 sec)

    mysql> insert into test3(name,age) values("abcd",-2147483648);
    Query OK, 1 row affected (0.00 sec)

    mysql> insert into test3(name,age) values("abcd",-2147483649);
    ERROR 1264 (22003): Out of range value for column 'age' at row 1
    mysql> insert into test3(name,age) values("abcd",2147483647);
    Query OK, 1 row affected (0.00 sec)

    mysql> insert into test3(name,age) values("abcd",2147483648);
    ERROR 1264 (22003): Out of range value for column 'age' at row 1
	
	bigint数据类型：
	mysql> create table test4(name varchar(16),age bigint);
    Query OK, 0 rows affected (0.02 sec)

    mysql> insert into test4(name,age) values("abcd",214748364858475695);
    Query OK, 1 row affected (0.01 sec)

小数存储：
	float数据类型
	mysql> create table test6(name varchar(16),age float);
    Query OK, 0 rows affected (0.02 sec)

    mysql> insert into test6(name,age) values("abcd",2.3333333333333333);
    Query OK, 1 row affected (0.00 sec)

    mysql> select * from test6;
    +------+---------+
    | name | age     |
    +------+---------+
    | abcd | 2.33333 |
    +------+---------+
    1 row in set (0.00 sec)

    mysql> insert into test6(name,age) values("abcd",2.11111111111133333333333);
    Query OK, 1 row affected (0.00 sec)

    mysql> select * from test6;
    +------+---------+
    | name | age     |
    +------+---------+
    | abcd | 2.33333 |
    | abcd | 2.11111 |
    +------+---------+
    2 rows in set (0.00 sec)
    mysql> insert into test6(name,age) values("abcd",2.66666666666633333);
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test6;
    +------+---------+
    | name | age     |
    +------+---------+
    | abcd | 2.33333 |
    | abcd | 2.11111 |
    | abcd | 2.66667 |
    +------+---------+
    3 rows in set (0.00 sec)

    mysql> insert into test6(name,age) values("abcd",2.666633333);
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test6;
    +------+---------+
    | name | age     |
    +------+---------+
    | abcd | 2.33333 |
    | abcd | 2.11111 |
    | abcd | 2.66667 |
    | abcd | 2.66663 |
    +------+---------+
    4 rows in set (0.00 sec)
	float进行小数存储，一般最多是通过五位的小数进行的存放，而且，最后一位进行四舍五入

	double数据类型：
	mysql> create table test7(name varchar(16),age double);
    Query OK, 0 rows affected (0.02 sec)

    mysql> insert into test7(name,age) values("abcd",2.000000000633333);
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test7;
    +------+-------------------+
    | name | age               |
    +------+-------------------+
    | abcd | 2.000000000633333 |
    +------+-------------------+
    1 row in set (0.00 sec)

    mysql> insert into test7(name,age) values("abcd",2.000000000633333999999999);
    Query OK, 1 row affected (0.00 sec)

    mysql> select * from test7;
    +------+-------------------+
    | name | age               |
    +------+-------------------+
    | abcd | 2.000000000633333 |
    | abcd | 2.000000000633334 |
    +------+-------------------+
    2 rows in set (0.00 sec)
	进行数据的存储，小数位比较多，可以使用double类型
	
	float和double 不精确的小数，
	
	decimal mysql中的小数类型，
	书写格式：decimal(数字最多的位数,小数占用几位)
    mysql> create table test8(name varchar(16),age decimal(6,2));
    Query OK, 0 rows affected (0.02 sec)

    mysql> insert into test8(name,age) values("abcd",1111.23);
    Query OK, 1 row affected (0.01 sec)

    mysql> insert into test8(name,age) values("abcd",11111.23);
    ERROR 1264 (22003): Out of range value for column 'age' at row 1
    mysql> insert into test8(name,age) values("abcd",1111.213);
    Query OK, 1 row affected, 1 warning (0.01 sec)

    mysql> select * from test8;
    +------+---------+
    | name | age     |
    +------+---------+
    | abcd | 1111.23 |
    | abcd | 1111.21 |
    +------+---------+
    2 rows in set (0.00 sec)

    mysql> insert into test8(name,age) values("abcd",11117.2);
    ERROR 1264 (22003): Out of range value for column 'age' at row 1
    mysql> insert into test8(name,age) values("abcd",1111.2);
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test8;
    +------+---------+
    | name | age     |
    +------+---------+
    | abcd | 1111.23 |
    | abcd | 1111.21 |
    | abcd | 1111.20 |
    +------+---------+
    3 rows in set (0.00 sec)


	java字符串类型					mysql字符串类型
	String								varchar
	char（字符类型，只能存储一个字符）	     	char
										  text 超出255
	
	char类型，可以进行字符串的存储
	mysql> create table test9(name char(16),age int);
    Query OK, 0 rows affected (0.02 sec)

    mysql> insert into test9(name,age) values('a',1);
    Query OK, 1 row affected (0.00 sec)

    mysql> insert into test9(name,age) values('afdfd',1);
    Query OK, 1 row affected (0.01 sec)
    
    插入数据的个数超出了当前这一列上的字符长度，出现报错：Data too long
    
    mysql> insert into test9(name,age) values('afdfd346546rferertrytryutuyrtewr',1);
ERROR 1406 (22001): Data too long for column 'name' at row 1
    
    mysql中，有两个字符串类型，字符串通过双引号引起也可以通过单引号引起，尽量使用单引号
    以后再java中书写语句，通过单引号进行数据的区分

	varchar 变长字符串，长度可以变化
	char    定长字符串，长度不可以改变
	char 定长字符串，只要创建表，指定了当前列上的字符串的长度，不管我们存储的数据长度是否到达了
	指定长度，都是通过这个长度进行的存储，
	例如：char(10) 列上进行数据存储，通过10个字符的长度进行的数据存储
		 插入数据，abc，三个字符，通过10个长度进行数据存储，剩下的7个位置通过空格进行存储
		注意特点：长度固定， 空间浪费，节省时间-----》空间换时间
		应用场景：身份证 手机号
	
	varchar 变长字符串，长度可以改变，
	例如：varchar（10），列上进行字符串的存储，最大字符个数10，
	如果插入了数据，abc，三个字符，进行长度的判断，可以进行数据存储，根据数据的实际长度进行运算
	实际的字符个数进行数据的存储，只使用3个长度进行数据存储，
	注意特点： 长度不固定，进行数据的运算，运算的时间，空间节省-----》空间换时间
		应用场景：商品名称，商品描述---》
		
	一般进行字符串数据存储，使用char和varchar，长度，一般最大255
	mysql> insert into test9(name,age) values('afdfd346546rferertrytryutuyrtewr',1);
    ERROR 1406 (22001): Data too long for column 'name' at row 1
    mysql> create table test9(name char(300),age int);
    ERROR 1074 (42000): Column length too big for column 'name' (max = 255); use BLOB or TEXT instead

    mysql> create table test11(name varchar(255),age int);
    Query OK, 0 rows affected (0.01 sec)

	进行字符串存储，text
	mysql> create table test12(name text,age int);
	Query OK, 0 rows affected (0.02 sec)


blob大对象类型
	可以存储图片，压缩包，视频，占用空间比较大的数据
这个数据类型以后用不上，
例如：100条数据，一个图片，1GB-----》blob 100GB---->表占用空间过大
	 100条数据，一个图片，1GB-----》字符串记录图片再电脑上的位置，1K 100KB空间---》
	 字符串记录图片位置，比较合适
	 数据获取，再100GB，再100KB空间内查找数据快
	 例如：搜 点击查看 ---》查 100次------》查询以后应用多
	 	  买东西，数据写入数据库，=====》相比较少
	
mysql 日期类型，进行时间（年月日 时分秒）的记录
	年月日 date
	mysql> create table test14(name varchar(16),birthday date);
    Query OK, 0 rows affected (0.02 sec)

    mysql> desc test14;
    +----------+-------------+------+-----+---------+-------+
    | Field    | Type        | Null | Key | Default | Extra |
    +----------+-------------+------+-----+---------+-------+
    | name     | varchar(16) | YES  |     | NULL    |       |
    | birthday | date        | YES  |     | NULL    |       |
    +----------+-------------+------+-----+---------+-------+
    2 rows in set (0.01 sec)

    mysql> insert into test14(name,birthday) values("abcd",20220210);
   
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test14;
    +------+------------+
    | name | birthday   |
    +------+------------+
    | abcd | 2022-02-10 |
    +------+------------+
    1 row in set (0.00 sec)

    mysql> insert into test14(name,birthday) values("abcd",2022210);
    ERROR 1292 (22007): Incorrect date value: '2022210' for column 'birthday' at row 1
    mysql> insert into test14(name,birthday) values("abcd",20220210);
    Query OK, 1 row affected (0.00 sec)
    
 =======》日期可以以数字的方式进行插入，格式是有要求的，年份4位 月份两位，日期两位
 		不满足格式，数据输入有误
	尽量的使用指定格式进行数据输入，通过字符串进行输入，可以使用符号进行数据的分割
	mysql> insert into test14(name,birthday) values("abcd","2022-2-10");
	Query OK, 1 row affected (0.00 sec)

	时分秒 time
	mysql> create table test15(name varchar(16),birthday time);
    Query OK, 0 rows affected (0.03 sec)

    mysql>
    mysql> insert into test15(name,birthday) values('abc',110920);
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test15
        -> ;
    +------+----------+
    | name | birthday |
    +------+----------+
    | abc  | 11:09:20 |
    +------+----------+
    1 row in set (0.00 sec)

    mysql> insert into test15(name,birthday) values('abc',11920);
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test15;
    +------+----------+
    | name | birthday |
    +------+----------+
    | abc  | 11:09:20 |
    | abc  | 01:19:20 |
    +------+----------+
    2 rows in set (0.00 sec)
    通过数字进行数据的存储，格式要求，小时两位，分钟两位，秒 两位
    如果不按照要求书写，虽然不会报错，但是数据有问题
    
    可以通过字符串，进行数据的插入
    mysql> insert into test15(name,birthday) values('abc',"11:9:20");
	Query OK, 1 row affected (0.01 sec)
    
    尽量进行输入插入时，使用字符串的格式进行数据插入，知道数字可以进行插入
    
    datetime 年月日时分秒
    mysql> create table test16(name varchar(16),birthday datetime);
    Query OK, 0 rows affected (0.02 sec)

    mysql> insert into test16(name,birthday) values('abcd',20220112162010);
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test16;
    +------+---------------------+
    | name | birthday            |
    +------+---------------------+
    | abcd | 2022-01-12 16:20:10 |
    +------+---------------------+
    1 row in set (0.00 sec)

    mysql> insert into test16(name,birthday) values('abcd',"2022-01-12 16:20:10");
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test16;
    +------+---------------------+
    | name | birthday            |
    +------+---------------------+
    | abcd | 2022-01-12 16:20:10 |
    | abcd | 2022-01-12 16:20:10 |
    +------+---------------------+
    2 rows in set (0.00 sec)

	timestamp 时间戳  年月日时分秒记录
	mysql> create table test17(name varchar(16),birthday timestamp);
    Query OK, 0 rows affected (0.01 sec)

    mysql> insert into test17(name,birthday) values("abc",20220212162010);
    Query OK, 1 row affected (0.01 sec)

    mysql> insert into test17(name,birthday) values("abc","2022-02-12 16:20:10");
    Query OK, 1 row affected (0.01 sec)

    mysql> insert into test16(name,birthday) values('abcd',"9999-01-12 16:20:10");
    Query OK, 1 row affected (0.00 sec)
    
    时间范围小，但是通过时间进行的唯一记录

	year 年份类型
    mysql> create table test18(name varchar(16),birthday year);
	Query OK, 0 rows affected (0.02 sec)
    mysql> insert into test18(birthday) values(2022);
    Query OK, 1 row affected (0.00 sec)
    mysql> insert into test18(birthday) values(69);
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test18;
    +------+----------+
    | name | birthday |
    +------+----------+
    | NULL |     2022 |
    | NULL |     2022 |
    | NULL |     1999 |
    | NULL |     2069 |
    +------+----------+
    4 rows in set (0.00 sec)

    mysql> insert into test18(birthday) values(70);
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test18;
    +------+----------+
    | name | birthday |
    +------+----------+
    | NULL |     2022 |
    | NULL |     2022 |
    | NULL |     1999 |
    | NULL |     2069 |
    | NULL |     1970 |
    +------+----------+
    5 rows in set (0.00 sec)
    mysql> insert into test18(birthday) values(0);
    Query OK, 1 row affected (0.00 sec)

    mysql> select * from test18;
    +------+----------+
    | name | birthday |
    +------+----------+
    | NULL |     2022 |
    | NULL |     2022 |
    | NULL |     1999 |
    | NULL |     2069 |
    | NULL |     1970 |
    | NULL |     0000 |
    +------+----------+
    6 rows in set (0.00 sec)
    
    输入的是两位的数字 1-69 2001-2069
    				70-99 1970-1999
   	输入的数字是0 存储的数据是 0000
   	
   	输入字符串格式的数字
   	mysql> insert into test18(birthday) values('70');
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test18;
    +------+----------+
    | name | birthday |
    +------+----------+
    | NULL |     2022 |
    | NULL |     2022 |
    | NULL |     1999 |
    | NULL |     2069 |
    | NULL |     1970 |
    | NULL |     0000 |
    | NULL |     1970 |
    +------+----------+
    7 rows in set (0.00 sec)

    mysql> insert into test18(birthday) values('69');
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test18;
    +------+----------+
    | name | birthday |
    +------+----------+
    | NULL |     2022 |
    | NULL |     2022 |
    | NULL |     1999 |
    | NULL |     2069 |
    | NULL |     1970 |
    | NULL |     0000 |
    | NULL |     1970 |
    | NULL |     2069 |
    +------+----------+
    8 rows in set (0.00 sec)
	输入的是两位的数字 1-69 2001-2069
    				70-99 1970-1999
   	输入的数字是0 存储的数据是 2000
   	
   	mysql> insert into test18(birthday) values('0');
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from test18;
    +------+----------+
    | name | birthday |
    +------+----------+
    | NULL |     2022 |
    | NULL |     2022 |
    | NULL |     1999 |
    | NULL |     2069 |
    | NULL |     1970 |
    | NULL |     0000 |
    | NULL |     1970 |
    | NULL |     2069 |
    | NULL |     2000 |
    +------+----------+
    9 rows in set (0.00 sec)
```

## mysql运算符

```mysql
有了数据类型，就可以通过运算符进行数据运算：
java中运算符：
	结果是数字的运算符
		算术运算符  + - * / % 
		复合运算符 += -= *= /= %=
		++ --  实现加一和减一的运算
		+ 正号  -  负号
		+ 字符串拼接
	结果是boolean的运算符
		
	
mysql中运算符
	算术运算符  + - * / % 
    update cat set age = age+3;
    Query OK, 3 rows affected (0.01 sec)
    mysql> update cat set age = age-2;
    Query OK, 3 rows affected (0.01 sec)
    mysql> update cat set age = age*3;
    Query OK, 3 rows affected (0.01 sec)
    mysql> update cat set age = age/4;
    Query OK, 3 rows affected (0.01 sec)
    mysql> update cat set age = age%2;
    Query OK, 3 rows affected (0.01 sec)

	mysql 数字有符号的数字 + 正号，- 表示负号


	注意：java中复合运算符再mysql中不存在
	mysql> update cat set age+=2;
    ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '+=2' at line 1
    mysql 不存在++ -- 运算符
    mysql> update cat set age++;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '++' at line 1

	mysql中 字符串拼接的情况不存在
	mysql> update cat set type = type+1;
    ERROR 1292 (22007): Truncated incorrect DOUBLE value: 'lanmao'
    相当于拿着列和数字进行了拼接，

尝试字符串数据和数字进行拼接-------》select进行操作
	mysql> select 1+1;
    +-----+
    | 1+1 |
    +-----+
    |   2 |
    +-----+
    1 row in set (0.00 sec)

    mysql> select 1+"abcd";
    +----------+
    | 1+"abcd" |
    +----------+
    |        1 |------》字符串首字母不是数字，字符串的值认为是0
    +----------+
    1 row in set, 1 warning (0.00 sec)

    mysql> select 1+"5abcd";
    +-----------+
    | 1+"5abcd" |
    +-----------+
    |         6 |------》字符串首字母是数字，拿着字符串上的数字进行运算
    +-----------+
    1 row in set, 1 warning (0.00 sec)
    
    mysql> select 1+"a5bcd";
    +-----------+
    | 1+"a5bcd" |
    +-----------+
    |         1 |---->首字母不是数字，都是0
    +-----------+
    1 row in set, 1 warning (0.00 sec)
    
    mysql> select "ac"+"ab";
    +-----------+
    | "ac"+"ab" |
    +-----------+
    |         0 |
    +-----------+
    1 row in set, 2 warnings (0.00 sec)
    mysql> select "ac"+1;
    +--------+
    | "ac"+1 |
    +--------+
    |      1 |
    +--------+
    1 row in set, 1 warning (0.00 sec)

年份也是数字，所以可以进行运算
	mysql> update test18 set birthday=birthday+20;
    Query OK, 9 rows affected (0.01 sec)
    Rows matched: 9  Changed: 9  Warnings: 0
    
    mysql> select * from test18;
    +------+----------+
    | name | birthday |
    +------+----------+
    | NULL |     2042 |
    | NULL |     2042 |
    | NULL |     2019 |
    | NULL |     2089 |
    | NULL |     1990 |
    | NULL |     2020 |
    | NULL |     1990 |
    | NULL |     2089 |
    | NULL |     2020 |
    +------+----------+
    9 rows in set (0.00 sec)

    mysql> create table t20(birdthday date);
    Query OK, 0 rows affected (0.02 sec)
    mysql> insert into t20(birdthday) values("2020-1-3");
    Query OK, 1 row affected (0.01 sec)

    mysql> select * from t20;
    +------------+
    | birdthday  |
    +------------+
    | 2020-01-03 |
    +------------+
    1 row in set (0.00 sec)

    mysql> update t20 set birdthday=birdthday+20;
    Query OK, 1 row affected (0.00 sec)
    Rows matched: 1  Changed: 1  Warnings: 0

    mysql> select * from t20;
    +------------+
    | birdthday  |
    +------------+
    | 2020-01-23 |
    +------------+
    1 row in set (0.00 sec)
    
    mysql> update t20 set birdthday=birdthday-30;
    ERROR 1292 (22007): Incorrect date value: '20200093' for column 'birdthday' at row 1
    mysql> update t20 set birdthday=birdthday+40;
    ERROR 1292 (22007): Incorrect date value: '20200163' for column 'birdthday' at row 1
    mysql> update t20 set birdthday=birdthday+8;
    Query OK, 1 row affected (0.01 sec)
    Rows matched: 1  Changed: 1  Warnings: 0	

	日期也可以进行+ 和 - 算术运算，只能再日期上进行运算，并且不能进行进位和退位的操作
	
	不能除法运算，乘法每个列上的值都会改变

mysql运算符，结果是否成立
	关系运算符： > >= < <= =(判断条件成立)  !=(判断条件不成立)  判断不成立<>
	update cat set age=age+2 where age=1;
    mysql> select 1=1;
    +-----+
    | 1=1 |
    +-----+
    |   1 |
    +-----+
    1 row in set (0.00 sec)

    mysql> select 1!=1;
    +------+
    | 1!=1 |
    +------+
    |    0 |
    +------+
    1 row in set (0.00 sec)
    -----》条件是否成立，结果，如果成立，结果1 如果不成立 结果0
    
    mysql> update cat set age=age+3 where age>=4;
    Query OK, 2 rows affected (0.01 sec)
    Rows matched: 2  Changed: 2  Warnings: 0

    mysql> select * from cat;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | abcd |    3 | jiamao |
    | aaa  |    8 | NULL   |
    | bc   | NULL | lanmao |
    +------+------+--------+
    4 rows in set (0.00 sec)
	查询时不指定条件，全表查询，，指定条件，满足条件的数据可以进行显示
	mysql> select * from cat where age<=3;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | abcd |    3 | jiamao |
    +------+------+--------+
    1 row in set (0.00 sec)

    mysql> select * from cat where age=3;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | abcd |    3 | jiamao |
    +------+------+--------+
    1 row in set (0.00 sec)

    mysql> select * from cat where age!=3;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    2 rows in set (0.00 sec)
    
    mysql> select * from cat where age<>3;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    2 rows in set (0.00 sec)

	逻辑运算符：一般不用符号进行书写 ，用关键词替代
		并且  &&   and
		或者 ||    or
		取反  !    not
	where后写多个条件，例如：age=3  并且 name="abcd" ---->显示
	例如：
		购物：注册账号，密码：登录账号，必须账号和密码同时正确才能登录
	mysql> select * from cat where age=3 and name="abcd";
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | abcd |    3 | jiamao |
    +------+------+--------+
    1 row in set (0.00 sec)

    mysql> select * from cat where age=3 or name="abcd";
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | abcd |    3 | jiamao |
    +------+------+--------+
    1 row in set (0.00 sec)
    
	取反操作
	mysql> select * from cat where not age=3;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    2 rows in set (0.00 sec)
```

## mysql关键词进行运算

```mysql
Null的数据比较特殊：
	提供了对null进行查询的关键词
	数据如果是null 查询的关键词：is null
	如果查询不是null的数据，关键词 is not null

    mysql> select * from cat where not age=3;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    2 rows in set (0.00 sec)

    mysql> select * from cat;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | abcd |    3 | jiamao |
    | aaa  |    8 | NULL   |
    | bc   | NULL | lanmao |
    +------+------+--------+
    4 rows in set (0.00 sec)

    mysql> select * from cat where age=3;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | abcd |    3 | jiamao |
    +------+------+--------+
    1 row in set (0.00 sec)

查询age 是null的数据信息
    mysql> select * from cat where age = null;
    Empty set (0.00 sec)

    mysql> select * from cat where age = NULL;
    Empty set (0.00 sec)	

    mysql> select * from cat where age is NULL;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | bc   | NULL | lanmao |
    +------+------+--------+
    1 row in set (0.00 sec)

    mysql> select * from cat where age is not NULL;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | abcd |    3 | jiamao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    3 rows in set (0.00 sec)

	表示一个数据范围 between and 再。。之间 包含边界值
	      不在指定范围内，not between and 
	
	mysql> select * from cat where age between 3 and 8;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | abcd |    3 | jiamao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    3 rows in set (0.00 sec)

    mysql> select * from cat where age>=3 and age<=8;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | abcd |    3 | jiamao |
    | aaa  |    8 | NULL   |
    +------+------+--------+

	in （数据进行一一列举） 判断数据是否再指定的范围内（范围不是指定的一个区间），列举的数据
	不在指定的（）的范围内 not in(范围)
	例如：
		查询age 3，5，7，9
	
    mysql> select * from cat where age=3 or age=5 or age=7 or age=9;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | abcd |    3 | jiamao |
    +------+------+--------+
    2 rows in set (0.00 sec)

    mysql> select * from cat where age in (3,5,7,9,555,77);
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | abcd |    3 | jiamao |
    +------+------+--------+
    2 rows in set (0.00 sec)

	不在指定数据范围内的：
	mysql> select * from cat where age!=3 and age!=5 and age!=7 and age!=9;
    +------+------+------+
    | name | age  | type |
    +------+------+------+
    | aaa  |    8 | NULL |
    +------+------+------+
    1 row in set (0.00 sec)

	mysql> select * from cat where age not in (3,5,7,9,555,77);
    +------+------+------+
    | name | age  | type |
    +------+------+------+
    | aaa  |    8 | NULL |
    +------+------+------+
    1 row in set (0.00 sec)
    
-----------------------》查询，条件中书写的都是具体值------》具体查询
============》查询，条件比较模糊，
	例如：姓 金 ，==========》模糊查询
	like 像。。。。
	进行模糊查询，一定要通过匹配符进行书写，_ 代表一个字符   % 任意多个字符
	mysql> select * from cat where name like 'a';
	Empty set (0.00 sec)
	查询，名字中有a的数据，a 开头还是末尾，   %a%
	mysql> select * from cat where name like '%a%';
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | abcd |    3 | jiamao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    2 rows in set (0.00 sec)
    
    数据第一个字符是a
    mysql> select * from cat where name like 'a%';
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | abcd |    3 | jiamao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    2 rows in set (0.00 sec)

	数据最后一个字符是a
	mysql> select * from cat where name like '%a';
    +------+------+------+
    | name | age  | type |
    +------+------+------+
    | aaa  |    8 | NULL |
    +------+------+------+
    1 row in set (0.00 sec)	

	数据第二个字符是a的语句
    mysql> select * from cat where name like '_a%';
    +------+------+------+
    | name | age  | type |
    +------+------+------+
    | aaa  |    8 | NULL |
    +------+------+------+
    1 row in set (0.00 sec)
 
 排序关键词  order by 根据哪个列进行排序 列名
例如：
	网上购物，查一个商品，搜索，价格排序，查询到的数据可以进行排序
   查询后的数据，进行排序，只是显示时进行的排序，数据库中不进行任何的改变
   mysql> select * from cat order by age;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | bc   | NULL | lanmao |
    | abcd |    3 | jiamao |
    | NULL |    7 | lanmao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    4 rows in set (0.00 sec)

    mysql> select * from cat;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | NULL |    7 | lanmao |
    | abcd |    3 | jiamao |
    | aaa  |    8 | NULL   |
    | bc   | NULL | lanmao |
    +------+------+--------+
    4 rows in set (0.00 sec)
    排序：有自己的默认的排序规则：从小到大进行升序排列
    排序的时候，默认的排序规则，升序 asc（可以省略的）
    mysql> select * from cat order by age asc;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | bc   | NULL | lanmao |
    | abcd |    3 | jiamao |
    | NULL |    7 | lanmao |
    | aaa  |    8 | NULL   |
    +------+------+--------+
    4 rows in set (0.00 sec)	
    降序排序关键词：desc
    
    mysql> select * from cat order by age desc;
    +------+------+--------+
    | name | age  | type   |
    +------+------+--------+
    | aaa  |    8 | NULL   |
    | NULL |    7 | lanmao |
    | abcd |    3 | jiamao |
    | bc   | NULL | lanmao |
    +------+------+--------+
    4 rows in set (0.00 sec)
    
    mysql> select distinct age,name from cat order by age asc,name desc ;
    +------+--------+
    | age  | name   |
    +------+--------+
    | NULL | bc     |
    |    3 | abcd   |
    |    7 | tomcat |
    |    7 | NULL   |
    +------+--------+
    4 rows in set (0.00 sec)

排序后的数据，指定数据显示的条数 limit 数据从第几条开始显示（从0开始的）, 显示几条数据
	mysql> select age from cat order by age desc limit 0,1;
    +------+
    | age  |
    +------+
    |    8 |
    +------+
    1 row in set (0.00 sec)
    
排序和limit可以再删除中进行使用
	limit 默认从第一条开始删除，所以参数只能写要删几条
    mysql> delete from cat order by age desc limit 1;
    Query OK, 1 row affected (0.00 sec)

去重操作  distinct
	所有的age值，重复的不进行查看
	mysql> select distinct age from cat order by age desc;
    +------+
    | age  |
    +------+
    |    7 |
    |    3 |
    | NULL |
    +------+
    3 rows in set (0.00 sec)

一个sql语句中不能出现多个相同的关键词
    mysql> select distinct age,distinct name from cat order by age desc;
    ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'distinct name from cat order by age desc' at line 1

    mysql> select distinct age,name from cat;
    +------+--------+
    | age  | name   |
    +------+--------+
    |    7 | NULL   |
    |    3 | abcd   |
    | NULL | bc     |
    |    7 | tomcat |
    +------+--------+
    4 rows in set (0.00 sec)
    
 as关键词：作为什么
 	给列起别名，关键词可以省略
 	mysql> select age as '年龄' from cat;
    +------+
    | 年龄 |
    +------+
    |    7 |
    |    3 |
    | NULL |
    |    7 |
    |    3 |
    +------+
    5 rows in set (0.00 sec)
    
    mysql> select age '年龄' from cat;
    +------+
    | 年龄 |
    +------+
    |    7 |
    |    3 |
    | NULL |
    |    7 |
    |    3 |
    +------+
    5 rows in set (0.00 sec)
```

## 不同类型的常用方法

```mysql
java中有了数据类型，
	数据的运算，通过运算符进行运算，
	根据数据类型的不同，有不同的方法进行运算

mysql有数据类型，通过运算符进行运算，
	根据数据类型的不同，有不同的方法进行运算
	以后进行表创建时，合理的选择数据类型，不同的类型有不同的功能
	
数字常用方法：
	mysql> select ceil(6.1);向上取整
    +-----------+
    | ceil(6.1) |
    +-----------+
    |         7 |
    +-----------+
    1 row in set (0.00 sec)

    mysql> select floor(6.9);向下取整
    +------------+
    | floor(6.9) |
    +------------+
    |          6 |
    +------------+
    1 row in set (0.00 sec)

	mysql> select round(6.4);------》四舍五入
    +------------+
    | round(6.4) |
    +------------+
    |          6 |
    +------------+
    1 row in set (0.00 sec)

    mysql> select round(6.5);
    +------------+
    | round(6.5) |
    +------------+
    |          7 |
    +------------+
    1 row in set (0.00 sec)
    
    mysql> select rand();------》随机数的产生，范围0-1
    +---------------------+
    | rand()              |
    +---------------------+
    | 0.03182857114060649 |
    +---------------------+
    1 row in set (0.00 sec)

    mysql> select rand();
    +--------------------+
    | rand()             |
    +--------------------+
    | 0.7639305384493718 |
    +--------------------+
    1 row in set (0.00 sec)
    
    mysql> select sqrt(9)----》平方根
    -> ;
    +---------+
    | sqrt(9) |
    +---------+
    |       3 |
    +---------+
    1 row in set (0.00 sec)

	mysql> select pow(3,3);-------》一个数的几次方
    +----------+
    | pow(3,3) |
    +----------+
    |       27 |
    +----------+
    1 row in set (0.00 sec)
	
	mysql>  select name,pow(age,2) from cat;
    +--------+------------+
    | name   | pow(age,2) |
    +--------+------------+
    | NULL   |         49 |
    | abcd   |          9 |
    | bc     |       NULL |
    | tomcat |         49 |
    | abcd   |          9 |
    +--------+------------+
    5 rows in set (0.00 sec)
	
	mysql> select PI();----》pi值
    +----------+
    | PI()     |
    +----------+
    | 3.141593 |
    +----------+
    1 row in set (0.00 sec)
    
	mysql> select sin(30*PI()/180);
    +---------------------+
    | sin(30*PI()/180)    |
    +---------------------+
    | 0.49999999999999994 |
    +---------------------+
    1 row in set (0.00 sec)	

字符串的常用方法
	再命令行中不合适查看
	
	进行不同语言的数据的存储，需要有不同的编码集，不同的编码集可以存储不同语言的数据
	mysql数据库，默认使用latin1进行数据存储，不支持中文
	
	命令行中写中文，是命令行当前编码是默认的gbk，中文就可以显示
	
	常用的中文编码集
		gbk --------》一个中文占用2个字节
		utf-8------->编码集比较多
		进行中文的存储，一个中文占用3个字节
		unicode存储中文，一个中文占用4个字节
		java中进行查看：
	public static void main(String[] args) throws UnsupportedEncodingException {
        String a = "中";
        /*byte[] bytes = a.getBytes("utf-8");
        System.out.println(bytes.length);*/----》3个字节

       /* byte[] bytes = a.getBytes("gbk");
        System.out.println(bytes.length);*/------》2个字节

        byte[] unicodes = a.getBytes("unicode");
        System.out.println(unicodes.length);------4个字节
    }	
		
进行字符串方法的查看，不能再命令的客户端中进行查看
	换一个客户端，第三方客户端（不是mysql自带的）------》navicat（视图化软件）

navicat是第三方客户端，不仅仅可以连接mysql数据库，还可以连接其他的数据库
	使用navicat流程：
	1 创建和mysql服务之间的连接，选择数据库的类型
	2 连接时，指定相关信息，mysql服务安装的 主机：ip 本机127.0.0.1  端口号：port  3306
		用户名：内置用户 root   密码：安装时输入密码，

	3 打开命令行，输入sql语句进行执行（缺点）
	3 创建一个查询窗口
	4 再窗口中进行sql语句的输入（提醒 关键词提醒，方法提醒）
	5 运行按钮，（运行，sql语句发送给mysql服务，执行sql语句，返回结果进行显示）
	6 关闭
	
	mysql> insert into cat(name,age,type) values("ab",2,"中文");
	1366 - Incorrect string value: '\xE4\xB8\xAD\xE6\x96\x87' for column 'type' at row 1
	'\xE4\xB8\xAD\xE6\x96\x87'-------》当前编码集不能存储中文
	数据库可以存储中文，修改编码集。
	
	创建数据库时，没有指定编码集，使用mysql默认的编码集进行数据的存放
	展示创建数据库的sql语句
	mysql> show create database d1;
    +----------+---------------------------------------------------------------+
    | Database | Create Database                                               |
    +----------+---------------------------------------------------------------+
    | d1       | CREATE DATABASE `d1` /*!40100 DEFAULT CHARACTER SET latin1 */ |
    +----------+---------------------------------------------------------------+
    1 row in set (0.03 sec)
    table表存储数据的编码集默认是latin1的编码集
    
    mysql> show create table cat;
    | Table | Create Table                                                                   
    | cat   | CREATE TABLE `cat` (
      `name` varchar(16) ,
      `age` int(11) DEFAULT NULL,
      `type` varchar(16) DEFAULT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=latin1 

    1 row in set (0.05 sec)
    
    数据库可以创建表时，指定编码集，一个数据库下的表的编码集可以自己指定
    mysql> create table cat1(name varchar(10), age int ,type varchar(10)) default charset='utf8';
    Query OK, 0 rows affected (0.03 sec)
    
    
    创建数据库时，指定数据库存储数据的编码集
    mysql中的utf8编码集
    mysql> create database d2 character set 'utf8';
	Query OK, 1 row affected (0.00 sec)
    
    如果创建数据库时，指定了编码集，之后再数据库中创建的所有的表的编码集默认都是utf8的编码集
	mysql> use d2;
    Database changed
    mysql> create table cat(name varchar(16),age int ,type varchar(16));
    Query OK, 0 rows affected (0.02 sec)
	mysql> show create table cat;
    | Table | Create Table                                                                            
    | cat   | CREATE TABLE `cat` (
      `name` varchar(16) DEFAULT NULL,
      `age` int(11) DEFAULT NULL,
      `type` varchar(16) DEFAULT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 
    1 row in set (0.03 sec)
	
	编码集支持中文，中文放到数据库中进行存储
	mysql> insert into cat(name,age,type) values("tomcat",3,"加菲猫");
	Query OK, 1 row affected (0.01 sec)
	
字符串常用方法：以后进行数据存储，字符串，可以结合字符串中的方法进行数据的运算
	select LENGTH("加菲猫") from cat;----》返回的字符串占用的字节长度
	结果：9 
	SELECT CHAR_LENGTH("加菲猫") from cat---》返回字符串中字符的个数
	结果：3
	select substr("abcd",1,2)------》截取字符串的方法，开始的位置从1开始，写了长度，按照长度截取
	结果：ab
	select substr("abcd",3)----》截取字符串，如果只写了开始截取的位置，默认截取到末尾
	结果：cd
	select left("abcd",2)----从左开始截取指定个字符
	结果：ab
	select right("abcd",3)------从左开始截取指定个字符
	结果：bcd
	大小写转换
	select upper("abcd") =====》转大写
	select lower("AFDFDF")-----》转小写
	
	select concat(upper(left(name,1)),lower(substr(name,2))) from cat;
	方法进行结合的使用
	
	concat（字符串，字符串，。。。。。。。）连接任意多个字符串
	
	select repeat("abc",3)-----》数据重复指定次数
	结果：abcabcabc
	
	select trim("   ab  cd    ") 去掉前后空白
	select rtrim("   ab  cd    ")去掉右侧空白
	select ltrim("   ab  cd    ")去掉左侧空白
	
日期常用方法：
	select now()  获取当前系统时间
	2022-02-13 16:58:05
	
	select current_date()获取当前系统的日期
	select curdate()
	
	select current_time()获取当前系统的时间
	select curtime()
	
	select year(now())
    select month(now())
    select day(now())
    select hour(now())
    select minute(now())
    select second(now())
    
    获取一个月的倒数第二天
    last_day(日期）  获取到当前日期的最后一天
    
    以后创建表，表的列名再数据库中有专门的称呼，字段名，
    
    生日到现在的日期，时间间隔
    timestampdiff(单位，开始的日期，结束的日期)进行时间间隔的运算
     例如：计算员工的入职时间
	select timestampdiff(month,birthday,now()) from t1;
             
     数据库进行表的创建，选择合适的数据类型，不同的数据类型，进行不同的运算
     不同的数据类型，有自己独特的方法进行运算，        
                  
```

# day4

## 聚合函数

```mysql
聚合函数，基于以后的数据进行的运算，统计出一个数据（根据条件进行数据的统计），
聚合函数不能进行嵌套
五个：
	sum() 求和  
		基于数字才能进行求和 select sum(sage) from student;
		求和时，数据类型是字符串，结果是0
	avg() 平均值
		select avg(sage) from student;=======》平均值的运算，默认不计入null值
		select avg(if(sage is null,0,sage)) from student;
		进行null的情况判断 if（）
	
	count() 统计数量
		进行数据条数的统计，不关心数据的类型，
		select count(sage) from student======9
		sname 统计的数据正好就是表中数据的条数
		select count(sname) from student----》10
		数据统计，如果是null，默认不计数
		==============================》问题：进行数据统计，null不计数，
		以后进行数据的统计，根据那一列统计，麻烦，（每一列上可能都会有null值）
	max() 最大值
		最大值的运算，如果是数字，结果最大的数字值
		进行的运算，是字符串类型，字符串的值是英文的，a-z默认的顺序
		select max(sname) from student;
		字符串的值是中文，按照编码集的数字大小排序查找的
	min() 最小值
		select min(sage) from student;
		select max(birthday) from t1;--------》日期
		一般情况，只对数字和日期进行最大值和最小值的运算

聚合函数，基于我们现在的整个表进行的数据统计，
	例如：生活中统计
		学校，总学生的数量：300
		按照年龄分班级（分组），10个班，每个班进行学生信息的统计
		一个学校是一个整体，整体中，分成不同的小的整体，小整体进行数据的统计
	一个表中的数据，就是一个大的整体，默认是对当前的表进行的统计
    表中的数据按照指定的条件进行分组，每一个小组可以进行相关统计

	分组关键词：group by 字段名 
				把当前字段上值相同的进行了一组数据的归类划分
	根据性别进行分组
    select ssex,count(ssex) from student GROUP BY ssex;
	根据系进行分组
    select dept,count(dept) from student 
    group by dept

	分组后的数据也可以进行条件的指定  having指定条件（where不可以）
	select dept,count(dept) from student 
	group by dept having count(dept)>=3
	
	使用having时，having后的字段名一定要再前面出现过，否则
	> 1054 - Unknown column 'sname' in 'having clause'
	> 时间: 0s

	select dept,count(dept) from student 
    group by dept having count(dept)>=3 and 
    sname='张三'-----------》出现报错
    
    select sname,dept,count(dept) from student 
    group by dept having count(dept)>=3 and 
    sname='张三'
```

## 数据库的三范式

```mysql
问题：
1 count()计数，可能因为null，不能进行数据的统计
2 一个表中，两条数据相同的情况，没有办法进行数据的区分
=======================================》以后进行表格创建，遵循mysql的规则

第一范式：
	表中的数据具有原子性：（一列中的数据不可拆分成多个列）
	例如：一个列上的数据进行输入
		（fjdk,20,男,计算机系，）列可以进行拆分------》不满足原子性，
	以后创建表，为了保证原子性，一般一个列上只存储当前这个特征上的值
	
第二范式：
	表中的数据唯一，通过字段，进行数据唯一性的记录，-----》约束
	约束：
		例如：上课，坐着，-----------》约束
			上班，坐着，=============》约束
	约束，表中的数据具有指定的规则		
	主键约束：
		特征：非空（不是null），而且不能重复
			一个表中，只能有一个主键
	创建表时，表中的一列数据上进行主键的创建，一般主键使用数字类型
		create table t2(
        id int primary key,-------------》主键的书写
        name varchar(16),
        age int,
        sex varchar(1)
    )
    > OK
    > 时间: 0.025s

	数据插入：
		insert into t2(id,name,age,sex) values(1,'abcd',20,'男')
    > 1062 - Duplicate entry '1' for key 'PRIMARY'-----》主键上值重复，出现报错
    > 时间: 0.001s
	
	数据插入：
	insert into t2(id,name,age,sex) values(null,'abcd',20,'男')
    > 1048 - Column 'id' cannot be null=======》主键上不能为null
    > 时间: 0.001s
	
	数据插入：
    insert into t2(name,age,sex) values('abcd',20,'男')
    > 1364 - Field 'id' doesn't have a default value
    > 时间: 0s '
	进行数据插入，如果一个列上没有输入数据，默认是null,但是主键上不能是null，
	主键上的值必须要输入，手动的进行输入，进行数据的唯一性的控制，比较麻烦
	mysql数据库自己进行主键上值得唯一性得控制，创建主键时，设置自增

	设置自增：
	create table t3(
        id int primary key auto_increment,
        name varchar(16),
        age int,
        sex varchar(1)
    )
    > OK
    > 时间: 0.015s
	
	设置了自增，如果要写自己写一个id得值，也可以，不受影响
	如果自己设置了id，自增是从最后一个自增得数据值开始还是从我们设置得值开始自增？
	从比较大得数据开始自增合理

	主键是否可以设置字符串并自增？
	create table t4(
        id varchar(10) primary key auto_increment,
        name varchar(16),
        age int,
        sex varchar(1)
    )
    > 1063 - Incorrect column specifier for column 'id'=====》字符串不能设置自增
    > 时间: 0s

	create table t4(
        id varchar(10) primary key,
        name varchar(16),
        age int,
        sex varchar(1)
    )
    > OK
    > 时间: 0.021s------------------》字符串类型可以设置主键，

--  同一个网址上，用户名是不可以重复，name也设置一个主键，
    create table t5(
        id int  primary key auto_increment,
        name varchar(16) primary key,
        age int,
        sex varchar(1)
    )
    > 1068 - Multiple primary key defined-----》多个主键被定义
    > 时间: 0s================================》一个表中，只能有一个主键

	主键进行分类：
		1 单列主键，主键创建在一个列上
			create table t4(
                id varchar(10) primary key auto_increment,
                name varchar(16),
                age int,
                sex varchar(1)
            )
            一般单列主键，书写位置写在字段（列）名中，--------》列级约束
            
		2 联合主键(多个列联合起来，形成了一个主键)
			不能用列级约束进行书写，跟列平级得位置进行书写，写再表中------》表级约束
			create table t4(
                id varchar(10) auto_increment,
                name varchar(16),
                age int,
                sex varchar(1),
                primary key(id,name)
            )

	---------》类似于sc表中，两个列上得数据不能同时重复，联合主键
	
	
	表中其他约束：
	--  同一个网址上，用户名是不可以重复，值是唯一的 ---
	表中，唯一约束，值是唯一的 unique
	
	create table t6(
        id int  primary key auto_increment,
        name varchar(16) unique,-------------》值唯一约束，（null不算数据值）
        age int,
        sex varchar(1)
    )
    > OK
    > 时间: 0.015s
	插入数据：
		insert into t6(name,age,sex) values("abcd",3,'男')
    > 1062 - Duplicate entry 'abcd' for key 'name'
    > 时间: 0.006s
	
	创建表：
		create table t7(
            id int  primary key auto_increment,
            name varchar(16) unique,
            age int unique,
            sex varchar(1) unique
        )
        > OK
        > 时间: 0.017s-----------------》唯一约束可以有多个
        
       ---一个网站注册用户名，不仅仅要唯一，还要不能是空 
       约束：not null 
       create table t8(
            id int  primary key auto_increment,
            name varchar(16) unique not null,
            age int not null,
            sex varchar(1)
        )
        > OK
        > 时间: 0.022s--》一个表中可以有多个非空约束，
        非空和唯一可以结合使用
	插入数据：
		insert into t8(name,sex) values("abc",'男')
        > 1364 - Field 'age' doesn't have a default value  '
        > 时间: 0.001s
	创建非空约束时，可以指定默认值，如果当前列上输入了数据，就是我们输入的值
	如果没有输入数据值，使用默认值，不会用null填充
     create table t9(
        id int  primary key auto_increment,
        name varchar(16) unique not null,
        age int not null default 20,-------》设置默认值
        sex varchar(1)
    )
    > OK
    > 时间: 0.023s  
第三范式：
	一个表中字段，不能有依赖关系，以后进行表创建，一个表描述一类事物
	========》进行了拆分后，表和表之间数据如何统一的====》通过外键进行的约束
	例如：
		学生：姓名，学号，课程号，成绩
		姓名和成绩之间，姓名依赖于学号，才能知道自己的成绩
		姓名和成绩之间，具有依赖关系
		
	需要将表进行拆分，拆分的原则，一个表对一类事物进行描述
		学号，姓名========》学生信息  例如  学号 1
		学号，课程，成绩=====》学生成绩表 例如  学号  0001
		
	表中的数据不用依赖于其他表存在的，这个表可以先创建
		create table ss2(
        sno int primary key auto_increment,
        name varchar(10),
        age int
    )
    依赖于其他表存在的表进行创建，
    	create table sc1(
        sno int,
        grade int,
        foreign key (sno) REFERENCES ss2(sno)----》外键，参照其他表中的列存在
    )
    > OK
    > 时间: 0.016s
    
    sc1表进行sno上数据的输入时，参照于ss2表中sno上的值，如果ss2表中sno上没有对应的值
    影响sc1表中数据的输入

	如果：学生信息还没有来得及录入系统，但是考试了，学生表中没有学生信息，
	导致成绩不能录入，-------------》如果没有外键，进行数据输入，更灵活一些
	
	进行数据删除不方便，必须把参照的数据删除后，被参照的数据才能删除，
	===================》java 耦合，一处代码修改，导致其他代码的修改，
	mysql表中，如果没有外键，灵活，如果有外键，一个表操作，另一个表需要改变===》
	外键，相当于表进行了耦合，所以，有外键，以后尽量的不要使用
	
```

# day5

## 数据库备份

通过navicat进行数据的备份，备份后，文件是以.sql的文件存储的

sql文件中存储是sql语句

sql文件可以进行运行，运行后形成表，如果有插入的语句，进行数据的插入

## 进行数据查询，再不同表中的列的显示

```mysql
数据存储，创建表，一个表中存储一类事物
进行数据查询，需要的显示的数据再不同的表中，该如何显示

例如：student，sc,
	查询，姓名，课程号，成绩
		 姓名再student表中，课程号和成绩再sc中

关键词：
	union 连接
	将两个查询的sql语句进行连接
	select sno,sname from student union select sno,grade from sc

	使用union 进行连接，两个查询语句的列数一致
	select sno,sname from student union select sno,grade,cno from sc
    > 1222 - The used SELECT statements have a different number of columns
    > 时间: 0s

	union进行两个表结果的连接，进行重复数据的去重
	
	union all 如果连接的表中有重复的数据，使用all不进行去重
	select * from t11 union all select * from t12

查询的数据不在一个表中，能不能把要查询的数据存在于一个表中
	================》表连接，进行查询时，表临时的连接成一个大表

	student表和sc表再查询时，连接成了一个大表，
	表中的数据的条数，特点：两个表中的数进行连接，第一个表的条数* 第二个表的条数
	=======================================》笛卡尔积
	select * from student,sc
	select * from student inner join sc
表连接时，指定连接条件：
	指定了连接条件，进行表的连接（表和表之间有连接字段）
	只有两个表中同时满足条件的数据才能进行显示
	=====================================》内连接
	
	select * from student,sc where student.sno=sc.sno;
	内连接还有另一种写法：
	select * from student inner join sc  on student.sno=sc.sno

外连接：
	左外连接
	例如：
		查询没有选课的同学的信息，（再sc中没有对应的选课信息的学生）
	-- left    主表 left 从表，
    -- 主表中数据全部显示，从表中数据满足条件的显示
    select * from student left join  sc on student.sno=sc.sno where sc.sno is null
	
	右外连接
	-- right   从表 right 主表，
    -- 主表中数据全部显示，从表中数据满足条件的显示
    select * from sc right join  student on student.sno=sc.sno where sc.sno is null

	查询哪些学生的信息再学生表中没有录入
	select * from student right join  sc on student.sno=sc.sno where student.sno is null
	
	表连接，可以将多个表进行连接：
		名字 课程名 成绩
		student course sc
	select * from student right join  sc on student.sno=sc.sno where student.sno is null
自连接：
	自己和自己进行连接
	select * from emp,emp
    > 1066 - Not unique table/alias: 'emp'
    > 时间: 0s
    ============》表一定要起别名  as
    
    -- 要查询的数据再同一个表中，使用自连接
    -- 将一个表模拟成两个表进行连接,给表起别名
    select * from emp as a,emp b where a.mgr=b.empno

```

## 视图view

```mysql
之前视图：
	例如：excel表，存储大量的数据，视图化进行显示
	例如：饼图 柱形图，基于表中的数据而存在，表中数据进行了删除，视图不存在

以后进行数据查询，多次再多个表中进行查询，多次使用表连接
---------------------》表连接的sql语句比较复杂，简化，简单
======》表连接的结果进行临时的存储

基于表中的数据而存在，表中数据进行了删除，视图不存在
创建视图：
	create view 名字 
	视图中的数据基于哪个表中的哪些列进行显示
	create view t12view as select * from t12
    > OK
    > 时间: 0.015s
	基于一个表进行的视图的创建，表中的数据如果进行了更新，视图中的数据随着改变
	视图中可以进行数据的删除，相当于表中的数据也进行了删除
	表中数据进行了添加，视图中也会改变
	==============》对表中数据的更新

	如果将创建视图需要的列进行了删除，导致视图无法打开
	
	表连接进行视图的创建
    注意：表中不要出现重复名字的列名
    create view test13 as select * from student inner join sc on student.sno=sc.sno inner join course on sc.cno=course.cno
	> 1060 - Duplicate column name 'sno'--------》sno多个
	> 时间: 0s
	
	进行列名的书写：
	create view test13 as select student.sno,sname,sage,ssex,dept,sc.cno,grade,course.cname,course.semester,course.credit from student inner join sc on student.sno=sc.sno inner join course on sc.cno=course.cno
    > OK
    > 时间: 0.005s
    
    表中的数据进行了更改，只要满足创建视图时的条件，就能再视图中进行显示
	通过sql语句再视图中进行数据查询：
	select sname,cname,grade from test13;（视图名）
	
	不能再多表连接的视图中，进行数据的删除，涉及到多个表的操作，不会到每个表中进行操作
	========》基于表存在的，视图中显示数据其实表中的数据，没有占用新的物理空间
```

## 索引结构

```mysql
索引：
	java数组，存储多个数据，索引，获取某个指定位置上的数据值
	通过索引获取数据，效率高，-----------》索引再大量的数据范围内提高查询数据的效率

生活中，大量的数据中，快速的进行数据的查找
例如：字典：数据量大，如何查询时效率高？
	提供了索引，（字典的目录的方式存在的）
	---------》字典有了目录，厚度进行增加，但是效率高
	
数据库，大量数据的存储，查找时效率问题，
	效率高，-----------》索引结构，加快查询效率
	代价：数据库表进行索引的创建，创建了索引的结构，增加表占用的空间

主键约束，非空，唯一，主键中默认存在一个索引（聚簇索引）
创建：
	create table t30(
        id int primary key auto_increment,
        name varchar(16),
        age int,
        sex varchar(2),
        dept varchar(16)

    )
    > OK
    > 时间: 0.02s
	数据插入：
	insert into t30(name,age,sex,dept) values("abcd2",14,'女','')
进行数据的查询
	主键查询
	select * from t30 where id=1
	普通列的查询
	select * from t30 where age=3
查看效率，通过关键词 explain的关键词进行效率的查看
mysql> explain  select * from t30 where id=1;
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | 
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-
|  1 | SIMPLE      | t30   | const | PRIMARY       | PRIMARY | 4       | const |    1 |       |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-
1 row in set (0.03 sec)


mysql> explain select * from t30 where age=3;
+----+-------------+-------+------+---------------+------+---------+------+------+------
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+------
|  1 | SIMPLE      | t30   | ALL  | NULL          | NULL | NULL    | NULL |    3 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.03 sec)

列的值的含义：
select_type:查询类型
simple：简单查询，效率高
union：使用union关键词时，使用的类型
SUBQUERY:子查询，效率最低

type:
const 常量
range:唯一索引 
ref:普通索引的类型
all：全表搜所

key_len:
	主键上的值类型int，const常量的长度 4 字节
	
possible_keys：
	查询时，可能用到的索引
	
rows:
	再表中进行指定数据的查询需要扫描表中的多少条数据
	
主键是字符串类型：
索引的长度比较长，占用空间比较多
mysql> explain  select * from t31 where id="001";
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | t31   | const | PRIMARY       | PRIMARY | 62      | const |    1 |       |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
1 row in set (0.03 sec)

一个列上有索引，查询效率高，以后不要再每个列上都创建索引，
频繁的根据某个列上的值进行数据的查询，数据量比较大（10万），创建索引
一个表中索引的个数尽量不要超过五个

索引占用空间，
	例如：字典：数据量比较大，进行目录的印刷
		杂志：20 ，目录，图，字，=======》印刷50页

创建索引
	create index 索引名 on 表（列名）
	create index test on t30(age)
    > OK
    > 时间: 0.025s
    创建索引，加快查询效率
    
 mysql> explain select * from t30 where age=3;
+----+-------------+-------+------+---------------+------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+-------+------+-------------+
|  1 | SIMPLE      | t30   | ref  | test          | test | 5       | const |    1 | Using where |
+----+-------------+-------+------+---------------+------+---------+-------+------+-------------+
1 row in set (0.05 sec)   

    mysql> explain select * from t30 where age=3;
+----+-------------+-------+------+---------------+------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+-------+------+-------------+
|  1 | SIMPLE      | t30   | ref  | test          | test | 5       | const |    2 | Using where |
+----+-------------+-------+------+---------------+------+---------+-------+------+-------------+
1 row in set (0.05 sec)
 
 create unique index 索引名 on 表（列）
 
 create unique index test1 on t30(name)
 
  mysql> explain select * from t30 where name="ab";
+----+-------------+-------+-------+---------------+-------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys | key   | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+---------------+-------+---------+-------+------+-------+
|  1 | SIMPLE      | t30   | const | test1         | test1 | 51      | const |    1 |       |
+----+-------------+-------+-------+---------------+-------+---------+-------+------+-------+
1 row in set (0.09 sec)  
    
mysql> explain select * from t30 union select * from t31;
+------+--------------+------------+------+---------------+------+---------+------+------+-------+
| id   | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra |
+------+--------------+------------+------+---------------+------+---------+------+------+-------+
|    1 | PRIMARY      | t30        | ALL  | NULL          | NULL | NULL    | NULL |    4 |       |
|    2 | UNION        | t31        | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
| NULL | UNION RESULT | <union1,2> | ALL  | NULL          | NULL | NULL    | NULL | NULL |       |
+------+--------------+------------+------+---------------+------+---------+------+------+-------+
3 rows in set (0.07 sec)    
  
  -- 子查询 查询语句作为其他的查询语句的条件
-- 和李勇再同一个系中的学生的姓名
select sname from student where dept = (select dept from student where sname="李勇")
  
  mysql> explain select sname from student where dept = (select dept from student where sname="李勇");
+----+-------------+---------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+---------+------+---------------+------+---------+------+------+-------------+
|  1 | PRIMARY     | student | ALL  | NULL          | NULL | NULL    | NULL |   11 | Using where |
|  2 | SUBQUERY    | student | ALL  | NULL          | NULL | NULL    | NULL |   11 | Using where |
+----+-------------+---------+------+---------------+------+---------+------+------+-------------+
2 rows in set (0.09 sec)  
    
具体查询，
====================>
模糊查询是支持索引的，
如果进行模糊查询，第一个字符是具体字符，支持索引
mysql> explain select * from t30 where name like 'b%';
+----+-------------+-------+-------+---------------+-------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key   | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+-------+---------+------+------+-------------+
|  1 | SIMPLE      | t30   | range | test1         | test1 | 51      | NULL |    1 | Using where |
+----+-------------+-------+-------+---------------+-------+---------+------+------+-------------+
1 row in set (0.03 sec)

如果进行模糊查询，第一个字符是匹配符，不支持索引

mysql> explain select * from t30 where name like '_b%';
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | t30   | ALL  | NULL          | NULL | NULL    | NULL |    5 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.06 sec)
    
```

# day6

## 数据库事务内容

```mysql
事务：
	是一个最小的执行单元（不可拆分），要么事务的内容都执行，要么都不执行
场景：
	例如：买东西：
		结账流程：扫码，----》付款码-----》商家账户加钱，自己的账户减钱
		=============================》最小的执行单元
		
购物网站上进行购物，（支付）============》

演示事务前，先看sql语句的执行：
	sql语句执行，分为两步
```

![sql执行](C:\Users\Tly\Desktop\sql执行.png)







```mysql
sql语句执行的过程中，没有写过提交，数据增删改，直接写道硬盘上了
---------------》mysql数据库中，自动提交autocommit 开启的。
show variables;
查看数据库中变量信息
autocommit:on ========>开启
查看事务，成为一个最小的执行的过程，（多个sql语句），
自动提交关闭
set autocommit=0
> OK
> 时间: 0s
show variables;
autocommit	OFF======>自动提交关闭

进行数据修改：
update t30 set age=5 where id=5

通过select语句进行查询，select * from t30;
再内存中获取到的数据，
实际硬盘上的数据并没有修改

手动提交： 内存数据写道硬盘上
commit
> OK
> 时间: 0.005s

事务：
	演示事务，一定要把自动提交关闭
	autocommit = off
事务是一个最小的执行单元
	开启一个事务：
		begin
	事务中的逻辑：
	insert into t30(name,age,sex) values('test',10,'女')

    update t30 set name='yyyy' where id=5;

    delete from t30 where id=2;

	
	事务回滚（事务中的sql语句内存中的数据被清理）：
	rollback
    > OK
    > 时间: 0.005s

	手动提交：提交后事务结束
	commit
    > OK
    > 时间: 0s

	事务特性：
		1 最小的执行单元： 原子性
		2 例如： 支付： 200 ，支付 300，数据改变的-----》一致性
		3 例如：支付宝，银行卡，------》300 同时花钱：200 200   
			当一个人正在支付时，另一个人要进行等待，===》隔离性
		4 例如：卡中余额的状态进行持久的保存，=====》持久性
		
	隔离性：
    	不同的隔离级别
    	级别不同，进行数据的操作不同
    	tx_isolation	REPEATABLE-READ  默认隔离级别是可重复读】
    	
        注意：每个客户端，都是进行了临时的提交和事务隔离级别的修改，如果客户端关闭了，
    	提交和隔离级别都会恢复成默认值
 	隔离级别：
    	读未提交：read-uncommitted 
    	两个客户端，一个先不提交，另一个读，--------》
   
    命令行中进行的操作：
    
    mysql> use s_t;
    Database changed
    mysql> set autocommit=0;
    Query OK, 0 rows affected (0.00 sec)

    mysql> set tx_isolation='read-uncommitted';
    Query OK, 0 rows affected (0.00 sec)
    
    begin
    
    mysql> select * from t30;
    +----+-------+------+------+------+
    | id | name  | age  | sex  | dept |
    +----+-------+------+------+------+
    |  1 | abcd  |    3 | ?    |      |
    |  3 | abcd2 |   14 | ?    |      |
    |  4 | ab    |    3 | ?    | NULL |
    |  5 | yyyy  |    5 | NULL | NULL |
    |  7 | test  |   10 | ?    | NULL |
    +----+-------+------+------+------+
    5 rows in set (0.00 sec)
    
    navicat客户端进行的操作：
    set autocommit=0

	set tx_isolation='read-uncommitted'

    begin
    update t30 set age=15 where id=5
    navicat中没有提交，命令中进行读取，
    命令行中进行数据的显示、：
    mysql> select * from t30;
    +----+-------+------+------+------+
    | id | name  | age  | sex  | dept |
    +----+-------+------+------+------+
    |  1 | abcd  |    3 | ?    |      |
    |  3 | abcd2 |   14 | ?    |      |
    |  4 | ab    |    3 | ?    | NULL |
    |  5 | yyyy  |   15 | NULL | NULL |------》age已经被修改了，但是navicat回滚了，这
    |  7 | test  |   10 | ?    | NULL |条数据就是读取到了错误的数据=====》脏读
    +----+-------+------+------+------+
    5 rows in set (0.00 sec)
    再navicat中进行回滚：
    ROLLBACK
	并提交
	commit;
    
    读未提交，客户端中读取的数据是错误的数据，出现脏读情况
    
    
    读已提交：read-committed   ，现象：不可重复读
    	一个客户端提交，另一个客户端进行读取
    命令行中进行的操作：
    mysql> set autocommit=0;
    Query OK, 0 rows affected (0.00 sec)

    mysql> set tx_isolation='read-committed';
    Query OK, 0 rows affected (0.00 sec)

    mysql> begin;
    Query OK, 0 rows affected (0.00 sec)

    mysql> select * from t30;
    +----+-------+------+------+------+
    | id | name  | age  | sex  | dept |
    +----+-------+------+------+------+
    |  1 | abcd  |    3 | ?    |      |
    |  3 | abcd2 |   14 | ?    |      |
    |  4 | ab    |    3 | ?    | NULL |
    |  5 | yyyy  |    5 | NULL | NULL |
    |  7 | test  |   10 | ?    | NULL |
    +----+-------+------+------+------+
    5 rows in set (0.00 sec)
    
    navicat进行的操作：
    set autocommit=0

	set tx_isolation='read-committed'

	begin
	update t30 set age=25 where id=5
    
    没提交的情况下，到命令行查看，可以避免脏读
    
    如果再navicat中进行了提交
    commit;
    
    再命令行中进行查看：
    mysql> select * from t30;
    +----+-------+------+------+------+
    | id | name  | age  | sex  | dept |
    +----+-------+------+------+------+
    |  1 | abcd  |    3 | ?    |      |
    |  3 | abcd2 |   14 | ?    |      |
    |  4 | ab    |    3 | ?    | NULL |
    |  5 | yyyy  |   25 | NULL | NULL |
    |  7 | test  |   10 | ?    | NULL |
    +----+-------+------+------+------+
    5 rows in set (0.00 sec)
    update的数据已经被修改了，一个事务中读取到的数据是不相同的
     
  	可重复读：repeatable-read  =======================》 
  		可以再一个事务中读取相同的数据
  		
     命令行中进行的操作：
     mysql> set autocommit=0;
    Query OK, 0 rows affected (0.00 sec)

    mysql> set tx_isolation='repeatable-read';
    Query OK, 0 rows affected (0.00 sec)

    mysql> begin;
    Query OK, 0 rows affected (0.00 sec)

    mysql> select * from t30;
    +----+-------+------+------+------+
    | id | name  | age  | sex  | dept |
    +----+-------+------+------+------+
    |  1 | abcd  |    3 | ?    |      |
    |  3 | abcd2 |   14 | ?    |      |
    |  4 | ab    |    3 | ?    | NULL |
    |  5 | yyyy  |   25 | NULL | NULL |
    |  7 | test  |   10 | ?    | NULL |
    +----+-------+------+------+------+
    5 rows in set (0.00 sec)
     
     navicat进行的操作：
     
    set autocommit=0

    set tx_isolation='repeatable-read'

    begin
    update t30 set age=35 where id=5
    需要再navicat中进行提交
    commit
    
    命令行中进行查询：
    mysql> select * from t30;
    +----+-------+------+------+------+
    | id | name  | age  | sex  | dept |
    +----+-------+------+------+------+
    |  1 | abcd  |    3 | ?    |      |
    |  3 | abcd2 |   14 | ?    |      |
    |  4 | ab    |    3 | ?    | NULL |
    |  5 | yyyy  |   25 | NULL | NULL |
    |  7 | test  |   10 | ?    | NULL |
    +----+-------+------+------+------+
    5 rows in set (0.00 sec)
    同一个事物中，读取到的数据是一致的，----------》可重复读
    
    
    命令中进行了提交，才能读取另一个客户端提交的数据
    mysql> commit;
    Query OK, 0 rows affected (0.00 sec)

    mysql> select * from t30;
    +----+-------+------+------+------+
    | id | name  | age  | sex  | dept |
    +----+-------+------+------+------+
    |  1 | abcd  |    3 | ?    |      |
    |  3 | abcd2 |   14 | ?    |      |
    |  4 | ab    |    3 | ?    | NULL |
    |  5 | yyyy  |   35 | NULL | NULL |
    |  7 | test  |   10 | ?    | NULL |
    +----+-------+------+------+------+
    5 rows in set (0.00 sec)
	
    串行化隔离级别：SERIALIZABLE
    navicat中进行操作：
    set autocommit=0

	set tx_isolation='SERIALIZABLE'
    
     begin
	update t30 set age=5 where id=5
	
    命令行中进行的操作：
    mysql> set autocommit=0;
    Query OK, 0 rows affected (0.00 sec)

    mysql> set tx_isolation='SERIALIZABLE';
    Query OK, 0 rows affected (0.00 sec)
   	mysql> begin;
    Query OK, 0 rows affected (0.00 sec)

    mysql> select * from t30;
    	查询结果一直不显示，
    	ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
	navicat中的事务没有提交，其他的客户端就要进行等待，navicat什么是事务提交
	命令行中什么时候进行显示
	
	串行化的隔离级别，表进行了锁定，=========》
	可重复读，锁定的一条数据================》
	
	=====================》隔离级别，命令行和navicat进行事务的操作	
	
```

## 数据库引擎：

```mysql
    CREATE TABLE `t30` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `name` varchar(16) DEFAULT NULL,
      `age` int(11) DEFAULT NULL,
      `sex` varchar(2) DEFAULT NULL,
      `dept` varchar(16) DEFAULT NULL,
      PRIMARY KEY (`id`),
      UNIQUE KEY `test1` (`name`),
      KEY `test` (`age`)
    ) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8

数据库引擎：
	ENGINE=InnoDB
	mysql默认的数据库引擎：innodb
数据库引擎不同，决定了表再硬盘上存储结构的不同

	innodb:只有这个引擎，支持事务，别的数据库引擎不支持
	
	myisam:	不支持事务

    create table t33(
         `id` int(11) NOT NULL AUTO_INCREMENT,
      `name` varchar(16) DEFAULT NULL,
      `age` int(11) DEFAULT NULL,
      `sex` varchar(2) DEFAULT NULL,
      `dept` varchar(16) DEFAULT NULL,
            PRIMARY KEY (`id`)
    )engine=myisam DEFAULT charset='utf8'
   
    set autocommit=0;

    begin;

    insert into t33(name,age,sex) values('ab',3,'男')

    rollback 
    不支持事务
    
    myisam：不涉及事务的操作，以后频繁进数据查询，使用当前引擎，=============》
    		支持全文索引，查询效率高===================》
    
     全部引擎：
     mysql> show engines;
     
     ============》数据库内容---------------------》
     java通过io进行存储，缺点，数据库替代java中io
```

## java操作数据库-------------》jdbc

```mysql
java操作数据库，通过java预留接口，哪个数据库希望可以被java操作，就书写对应的操作文档

接口实现解耦合
	数据库的类型很多，java给数据库预留了接口，数据库想要被java进行操作，遵循java的书写规则，
	进行功能类的书写。
	
数据库的厂商，写好了java预留接口的实现类，我们怎么使用？
	已经定义好的类，我们如何进行使用？
	我们之前写项目了，项目中也是类，类再不同的java项目中进行使用
	项目进行导出，导出为jar包（压缩包），class文件（字节码，可读性低）
	jar包，再需要使用包中类的项目中进行使用
	jar包放到项目中，jar包中的类我们可以进行使用
	
	我们使用别人写好的类，找到相应的jar包，进行jar包的导入
	
	------------------》java操作数据库，需要导入jar包
	
java操作数据的流程：
	java客户端，操作数据库服务
	java第三方客户端，navicat第三方客户端=========》操作流程，
    navicat操作流程：
    1 创建连接，选择数据库的类型mysql
    2 数据库所在的主机 host port user 密码
    3 选中数据库
    4 创建查询窗口
    5 写sql语句
    6 运行
    7 查看结果
    8 关闭
    
	java操作流程：
	1 导入数据库jar包
	2 java预留的是接口，jar包使用，进行驱动的导入（电脑上的接口，插入U盘，安装驱动）
		驱动只需要导入一次就够了，（代码再类加载时只执行一次----》static{}）
    3 创建连接，选择数据库的类型mysql--->对象，数据库所在的主机 host port user 密码，选中数据库
    4 创建查询窗口
    5 写sql语句
    6 查询窗口上的运行功能
    7 查看结果
    8 关闭
```

# day7

jdbc实现数据插入的代码：

```java
public class Demo {
    static {
        try {
            Class.forName("com.mysql.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) {
//        变量提升作用域
        Connection conn=null;
        Statement state=null;
        try {
//            创建连接
            conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/s_t", "root", "1234");
//            查询窗口
            state = conn.createStatement();
//          sql语句
            String str = "insert into student(sno,sname,sage,ssex,dept) values('0899910','java',20,'a','b')";
//            运行
            int i = state.executeUpdate(str);
//            查看运行结果
            System.out.println(i);

        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            //            资源关闭
//            再java中只要发生了异常，从上到下进行异常的查找，查找代码，要找我们自己写的代码
//            导入的其他jar包中的代码，不能进行修改
            try {
                state.close();
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }

        }


    }
}
实现了数据添加（修改和删除）的功能，进行封装，封装成方法------------》
	 public static void add(){
        //        变量提升作用域
        Connection conn=null;
        Statement state=null;
        try {
//            创建连接
            conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/s_t", "root", "1234");
//            查询窗口
            state = conn.createStatement();
//          sql语句
            String str = "insert into student(sno,sname,sage,ssex,dept) values('0899911','java',20,'a','b')";
//            运行
            int i = state.executeUpdate(str);
//            查看运行结果
            System.out.println(i);

        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            //            资源关闭
//            再java中只要发生了异常，从上到下进行异常的查找，查找代码，要找我们自己写的代码
//            导入的其他jar包中的代码，不能进行修改
            try {
                state.close();
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }

        }


    }

基于添加方法，进行方法的分析：
    方法的缺点：方法定义时，参数都是固定的，每次调用方法，都需要再调用前进行修改
     方法定义时：通用性，只要实现当前的逻辑，方法都可以进行使用
    
参数问题解决：
    public static void add(String sno,String sname,Integer sage,String ssex,String dept){
        //        变量提升作用域
        Connection conn=null;
        Statement state=null;
        try {
//            创建连接
            conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/s_t", "root", "1234");
//            查询窗口
            state = conn.createStatement();
//          sql语句
            
            第一种解决方式，参数放到sql语句中，出现的情况：
                不能识别变量对应的参数值，values中书写的是列名
            String str = "insert into student(sno,sname,sage,ssex,dept) values(sno,sname,sage,ssex,dept)";
            第二种解决方式，参数放到sql语句中，并且需要加单引号
            再mysql中，不认为这几个数据是参数，而是认为实际的数据值
            String str = "insert into student(sno,sname,sage,ssex,dept) values('sno','sname',sage,'s','dept')";
            
            第三种解决方式：既要满足mysql的需求，又要遵循java的变量的使用规则
            String str = "insert into student(sno,sname,sage,ssex,dept) values('"+sno+"','"+sname+"',"+sage+",'"+ssex+"','"+dept+"')";

            
//            运行
            int i = state.executeUpdate(str);
//            查看运行结果
            System.out.println(i);

        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            //            资源关闭
//            再java中只要发生了异常，从上到下进行异常的查找，查找代码，要找我们自己写的代码
//            导入的其他jar包中的代码，不能进行修改
            try {
                state.close();
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }

        }


    }

方法的形参可以再方法中，进行参数的使用，
    但是拼接时比较麻烦，单引号和双引号比较多，看着乱
    查询窗口不在使用statement，使用PreparedStatement的窗口
 public static void add1(String sno,String sname,Integer sage,String ssex,String dept){
        //        变量提升作用域
        Connection conn=null;
        PreparedStatement pstmt=null;
        try {
//            创建连接
            conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/s_t", "root", "1234");
//        固定的sql语句的部分进行书写,数据值的部分，通过?进行占位
            String sql = "insert into student(sno,sname,sage,ssex,dept) values(?,?,?,?,?)";
            //            创建查询窗口
//            PreparedStatement的窗口，需要把sql语句中固定的部分进行输入
//          进行操作的sql语句功能部分是固定的，每次插入的数据值不固定
            pstmt = conn.prepareStatement(sql);
//            sql语句只有固定的部分，？上的值还不确定，再运行前，需要把sql语句中？的位置上进行赋值
            //把sql语句补充完整的过程
//            pstmt.set+数据类型，给sno赋值，sno是字符串类型，setString
//            ?位置开始的值从1开始
            pstmt.setString(1,sno );
            pstmt.setString(2,sname );
            pstmt.setInt(3,sage );
            pstmt.setString(4, ssex);
            pstmt.setString(5, dept);
//            运行
            int i = pstmt.executeUpdate();

//            查看运行结果
            System.out.println(i);

        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            //            资源关闭
//            再java中只要发生了异常，从上到下进行异常的查找，查找代码，要找我们自己写的代码
//            导入的其他jar包中的代码，不能进行修改
            try {
                pstmt.close();
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }

        }
    }

进行了添加（修改，删除）的操作，
    查询窗口有两种类型
    Statement
    PreparedStatement
推荐使用    PreparedStatement，
    进行参数注入，进行书写比较简单

```

```java
观察增删改方法，方法sql语句不同，参数不同，其他的逻辑是相同的
    将增删改的方法，进行了一个方法的封装
    方法不仅仅可以对一个表进行操作，还可以对当前数据库下的其他的任意表进行操作
==========================》方法进行了封装，只要是对表进行增删改的操作，方法都可以使用    
 public static void test(String sql,Object... objs){//sql语句可以传入，参数个数不同可以处理
        Connection conn=null;
        PreparedStatement pstmt=null;
        try {
            conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/s_t", "root", "1234");
            pstmt = conn.prepareStatement(sql);
//            把sql语句补充完整
//            必须要通过sql语句才知道操作的数据库中的表是哪一个
//            什么时候书写sql语句，什么时候知道操作的表是哪一个，什么时候知道操作的数据是什么
//            当调用方法时，才能知道操作的是哪个表，参数是什么
//            sql语句补充完整
            for(int i = 0;i<objs.length;i++){
                pstmt.setObject(i+1, objs[i]);
            }

            int i = pstmt.executeUpdate();
            System.out.println(i);


        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                pstmt.close();
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

    }

性别用了其他的字母书写：
    中文进行插入时，中文再navicat中已？的方式进行的显示
    中文没有被识别，--------》都是编码集的问题
解决：
conn = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/s_t", "root", "1234");
//                                   https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1
前面是协议：//ip地址：端口号/数据库名字?地址的参数  key=value&key=value
    
conn = DriverManager
    .getConnection("jdbc:mysql://127.0.0.1:3306/s_t?useUnicode=true&characterEncoding=utf8", "root", "1234");

```

## 查询逻辑的书写

```java
获取连接
连接的参数特别长，书写多次，麻烦
如果以后要进行其他数据库的操作，查找所有的数据库相关连接信息，都要进行修改
=========》
    private static final String URL="jdbc:mysql://127.0.0.1:3306/s_t?useUnicode=true&characterEncoding=utf8";
    private static final String USER="root";
    private static final String PWD="1234";

  private static Connection getConn(){
        Connection conn=null;
        try {
            conn = DriverManager.getConnection(URL, USER, PWD);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }

简单的statement查询
public static void getALL(){
        Connection conn = getConn();
        Statement state=null;
        ResultSet resultSet=null;
        try {
             state = conn.createStatement();
            String sql = "select * from student";
            resultSet = state.executeQuery(sql);
//            自己遍历的方式  知不知道集合中数据的条数
            while(resultSet.next()){
                //判断是否有下一条数据 如果有就把这条数据中每个列上的值进行获取
//                resultSet.get+数据类型，例如，获取sno String，getString(列名)
                String sno = resultSet.getString("sno");
                String sname = resultSet.getString("sname");
                Integer sage = resultSet.getInt("sage");
                String ssex=resultSet.getString("ssex");
                String dept = resultSet.getString("dept");
//                每循环一次，拿到表中的一条数据
                System.out.println(sno+"   "+sname+"   "+sage+"   "+ssex+"   "+dept);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                conn.close();
                state.close();
                resultSet.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }

        }


    }

java中可以通过实体类对应表的信息，
    通过实体类的对象，对应到表中的每条数据信息
  public static void getALL(){
        List<Student> stus = new ArrayList<>();
        Connection conn = getConn();
        Statement state=null;
        ResultSet resultSet=null;
        try {
             state = conn.createStatement();
            String sql = "select * from student";
            resultSet = state.executeQuery(sql);
//            自己遍历的方式  知不知道集合中数据的条数
            while(resultSet.next()){
                //判断是否有下一条数据 如果有就把这条数据中每个列上的值进行获取
//                resultSet.get+数据类型，例如，获取sno String，getString(列名)
                Student s = new Student();
                String sno = resultSet.getString("sno");
                String sname = resultSet.getString("sname");
                Integer sage = resultSet.getInt("sage");
                String ssex=resultSet.getString("ssex");
                String dept = resultSet.getString("dept");
//                每循环一次，拿到表中的一条数据
//                再Java中进行的数据的打印，数据有没有体现出是一条数据
//                mysql中进行查询，已表格的形式存在的，一行就是一条数据
//                java中表示具有相同特征和行为的一类事物======》类表示
//                java中创建了和数据库中表对应的类，表中的列名是什么，java属性就是什么
//                表中列上是什么类型，java中对应的属性的类型就是什么
//                ===》java类对应数据库中的一个表----------》类 实体类  pojo
//                一个表中可以存储多条数据，一个类创建多个对象，一个对象就是一条具体的数据
//                  一个表中的一行数据就是通过java中的一个对象进行的表示
                s.setSno(sno);
                s.setDept(dept);
                s.setSsex(ssex);
                s.setSage(sage);
                s.setSname(sname);
                System.out.println(s);
                stus.add(s);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                conn.close();
                state.close();
                resultSet.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }

        }


    }
进行数据的查询，使用statement，虽然进行了参数的拼接，但是就一个参数，不是特别麻烦
    sql语句书写：
    String sql = "select * from student where sno='"+test+"'
    但是如果sql语句后写了一个恒成立的条件，导致sql数据库所有的数据都进行展示
    String sql = "select * from student where sno='"+test+"' or 1=1";
数据泄露，数据进行了窃取，---------------》数据不安全，====》sql注入 
   
Preparedstatement会不会出现sql注入的情况？？？？？？？？？？？？
    
      public static void getALL1(String test){
        List<Student> stus = new ArrayList<>();
        Connection conn = getConn();
        PreparedStatement pstmt=null;
        ResultSet resultSet=null;
        String sql = "select * from student where sno=?";
        try {
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1,test+"or 1=1" );========》注入不成功

            resultSet = pstmt.executeQuery();
//            自己遍历的方式  知不知道集合中数据的条数
            while(resultSet.next()){
                //判断是否有下一条数据 如果有就把这条数据中每个列上的值进行获取
//                resultSet.get+数据类型，例如，获取sno String，getString(列名)
                Student s = new Student();
                String sno = resultSet.getString("sno");
                String sname = resultSet.getString("sname");
                Integer sage = resultSet.getInt("sage");
                String ssex=resultSet.getString("ssex");
                String dept = resultSet.getString("dept");
//                每循环一次，拿到表中的一条数据
//                再Java中进行的数据的打印，数据有没有体现出是一条数据
//                mysql中进行查询，已表格的形式存在的，一行就是一条数据
//                java中表示具有相同特征和行为的一类事物======》类表示
//                java中创建了和数据库中表对应的类，表中的列名是什么，java属性就是什么
//                表中列上是什么类型，java中对应的属性的类型就是什么
//                ===》java类对应数据库中的一个表----------》类 实体类  pojo
//                一个表中可以存储多条数据，一个类创建多个对象，一个对象就是一条具体的数据
//                  一个表中的一行数据就是通过java中的一个对象进行的表示
                s.setSno(sno);
                s.setDept(dept);
                s.setSsex(ssex);
                s.setSage(sage);
                s.setSname(sname);
                System.out.println(s);
                stus.add(s);

            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                conn.close();
                pstmt.close();
                resultSet.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }

        }


    }

  Preparedstatement也会出现sql注入的情况，
      但是Preparedstatement 通过？进行的参数的注入，相比较Statement而言，安全一些
   网络的信息，没有绝对安全，相对安全
      
 Preparedstatement     和Statement比较：
      Statement出现sql注入的情况
      Preparedstatement相对而言，比较安全     
```

# day8

## 查询方法封装

```java
//    增删改的方法，通用方法，只要对当前数据库下的表进行操作，封装的方法可以实现
//    查询：通用的方法，只要对当前数据库下的表进行操作，封装的方法可以实现

//    不在类定义时进行泛型的指定，如果一个类中只有一个方法使用泛型，
//    可以只再当前的方法中进行泛型方法的定义
//    定义泛型方法：方法返回值前，加<T>
    public static <T> List<T> executeQuery(String sql,RowMap<T> rowMap,Object... objs){
//        'com.bjpowernode.utils.JdbcUtil.this' cannot be referenced from a static context
        List<T> stus = new ArrayList<>();
        Connection conn = getConn();
        PreparedStatement pstmt=null;
        ResultSet resultSet=null;
        try {
            pstmt = conn.prepareStatement(sql);
//           sql语句补充完整
//            标识sql语句，不用进行参数注入
            if(objs!=null){
                for (int i=0;i<objs.length;i++){
                    pstmt.setObject(i+1,objs[i] );
                }
            }
            resultSet = pstmt.executeQuery();
//            自己遍历的方式  知不知道集合中数据的条数
            while(resultSet.next()){
//              方法定义时，遍历结果集中的数据，数据对应成java中对象
//                定义时，不知道操作的是哪个表，也不知道哪个类进行对应
//                定义时不知道操作的类型，使用时可以进行类型的指定--》泛型
//          遍历结果，返回一个泛型类型的对象，放到集合中
//          遍历时，拿着resultSet中的一条数据，对应成一个泛型对象-----》定义方法
//
                T t = rowMap.rowMapping(resultSet);
                stus.add(t);

            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                conn.close();
                pstmt.close();
                resultSet.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return stus;
        }


    }
rowMap接口定义：
    public interface RowMap<T> {
        T rowMapping(ResultSet rs);
    }

方法调用：
    List<Student> stus = JdbcUtil.executeQuery("select * from student", new RowMap<Student>() {
            @Override
            public Student rowMapping(ResultSet rs) {
                Student s = new Student();
                try {
                    s.setSname(rs.getString("sname"));
                    s.setSage(rs.getInt("sage"));
                    s.setSsex(rs.getString("ssex"));
                    s.setDept(rs.getString("dept"));
                    s.setSno(rs.getString("sno"));
                } catch (SQLException e) {
                    e.printStackTrace();
                }
                return s;
            }
        }, null);

        for (Student s:stus
             ) {
            System.out.println(s);
        }

 List<Sc> scs = JdbcUtil.executeQuery("select * from sc", rs -> {
            Sc sc = new Sc();
            try {
                sc.setCno(rs.getString("cno"));
                sc.setSno(rs.getString("sno"));
                sc.setGrade(rs.getInt("grade"));
            } catch (SQLException e) {
                e.printStackTrace();
            }

            return sc;
        }, null);

实现了java中对数据库中表的操作，
    增删改封装成了方法==========》
    查询封装成了方法============》当前数据库中任意表进行操作
以后进行方法的封装，一定要先知道基本操作流程，再封装    

```

## 比较

```java
 PreparedStatement extends Statement
 关系：
 	PrepareStatement是子接口

通过增删改，PreparedStatement 和Statement：
	PreparedStatement参数注入方便
通过查询
	PreparedStatement 防止sql注入，相对于Statement安全
	
Statement：普通的查询窗口	
	什么时候执行sql语句，什么时候进行语句的编译
	
PreparedStatement：预处理，提前将sql语句固定的部分进行编译
	创建查询窗口时，进行了sql语句的编译，再执行时，不需要进行编译
效率比较：
     PreparedStatement效率高于Statement
     
	快慢，比较一条sql语句的执行效率，
		单条数据的执行，statement的时间21 12 9 
					 Preparedstatement 的时间 8 7 10 
		比较多条，同时对表中数据进行操作：批处理
基于以上比较：以后写代码，更推荐使用PrepareStatement	
     
public static void main(String[] args) {
        Connection conn=null;
        Statement state=null;
        try {
             conn = DriverManager.getConnection(URL, USER, PWD);
             state = conn.createStatement();
           /* String sql = "insert into student(sno,sname,sage,ssex,dept) values('0877703','java',16,'男','计算机系')";
            long start = System.currentTimeMillis();
            int i = state.executeUpdate(sql);
            System.out.println(System.currentTimeMillis()-start);*/
           for(int i = 0;i<100;i++){
               String sql = "insert into student(sno,sname,sage,ssex,dept) values('080000"+i+"','java',"+i+",'男','计算机系')";
//                jdbc 方法，实现批处理的操作
//               所有的sql语句，成为一个批次，
                state.addBatch(sql);
           }

//           一个批次的sql语句可以执行
            long start = System.currentTimeMillis();
            int[] ints = state.executeBatch();
            System.out.println(System.currentTimeMillis()-start);

        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                conn.close();
                state.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }


    }
Statement执行效率，执行100条数据，时间452ms
PreparedStatement执行效率，执行100条数据，时间380ms    

     public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pstmt = null;
        String sql = "insert into student(sno,sname,sage,ssex,dept) values(?,?,?,?,?)";
        try {
            conn= DriverManager.getConnection(URL,USER ,PWD );
            pstmt=conn.prepareStatement(sql);
            for (int i=0;i<100;i++){
                pstmt.setString(1,"086660"+i );
                pstmt.setString(2,"java" );
                pstmt.setInt(3,i );
                pstmt.setString(4,"男" );
                pstmt.setString(5,"计算机系" );

//                成为一个批次
                pstmt.addBatch();
            }

            long start = System.currentTimeMillis();
            int[] ints = pstmt.executeBatch();
            System.out.println(System.currentTimeMillis()-start);


        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                pstmt.close();
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
```

## 事务及隔离级别

```java
最小执行单元
  public static void main(String[] args) {
        Connection conn = null;
        PreparedStatement pstmt = null;
        String sql = "update student set sname=? where sno=?";
        try {
            conn = DriverManager.getConnection(URL, USER,PWD );
            conn.setAutoCommit(false);//自动提交关闭
            pstmt = conn.prepareStatement(sql);

//            设置事务隔离级别
//            tx_isolation 事务隔离级别
//            1 读未提交
            conn.setTransactionIsolation(1);
//            2 读已提交
            conn.setTransactionIsolation(2);
//            4 可以重复读
			conn.setTransactionIsolation(4);
 //           8 串行化
            conn.setTransactionIsolation(8);
            pstmt.setString(1,"xiugai" );
            pstmt.setString(2,"0822201" );


            int i = pstmt.executeUpdate();
            System.out.println(i);
            int a = 10/0;


            conn.commit();

        } catch (SQLException e) {
            e.printStackTrace();
            try {
                conn.rollback();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
        }finally {
            try {
                pstmt.close();
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }


    }
命令行中出现脏读情况：
    
mysql> select * from student;
+---------+--------+------+------+--------+--------+
| sno     | sname  | sage | ssex | dept   | is_del |
+---------+--------+------+------+--------+--------+
| 0811101 | ??     |   20 | ?    | ????   |      0 |
| 0811102 | ??     |   19 | ?    | ????   |      1 |
| 0811103 | ??     |   19 | ?    | ????   |      1 |
| 0811104 | ???    |   20 | ?    | ????   |      1 |
| 0811109 | abcd   | NULL | ?    | NULL   |      1 |
| 0811191 | ??     |   18 | ?    | ????   |      1 |
| 0821101 | ??     |   19 | ?    | ?????  |      1 |
| 0821102 | ??     |   20 | ?    | ?????  |      1 |
| 0821103 | ??     |   23 | ?    | ?????  |      1 |
| 0822201 | xiugai |   22 | NULL | NULL   |      1 |=============
| 0831101 | ???    |   22 | ?    | ?????  |      1 |
+---------+--------+------+------+--------+--------+
11 rows in set (0.00 sec)

mysql> select * from student;
+---------+-------+------+------+--------+--------+
| sno     | sname | sage | ssex | dept   | is_del |
+---------+-------+------+------+--------+--------+
| 0811101 | ??    |   20 | ?    | ????   |      0 |
| 0811102 | ??    |   19 | ?    | ????   |      1 |
| 0811103 | ??    |   19 | ?    | ????   |      1 |
| 0811104 | ???   |   20 | ?    | ????   |      1 |
| 0811109 | abcd  | NULL | ?    | NULL   |      1 |
| 0811191 | ??    |   18 | ?    | ????   |      1 |
| 0821101 | ??    |   19 | ?    | ?????  |      1 |
| 0821102 | ??    |   20 | ?    | ?????  |      1 |
| 0821103 | ??    |   23 | ?    | ?????  |      1 |
| 0822201 | abcd  |   22 | NULL | NULL   |      1 |==============
| 0831101 | ???   |   22 | ?    | ?????  |      1 |
+---------+-------+------+------+--------+--------+
11 rows in set (0.00 sec)

命令行中的不可重复读（读已提交）
    mysql> select * from student;
    +---------+-------+------+------+--------+--------+
    | sno     | sname | sage | ssex | dept   | is_del |
    +---------+-------+------+------+--------+--------+
    | 0811101 | ??    |   20 | ?    | ????   |      0 |
    | 0811102 | ??    |   19 | ?    | ????   |      1 |
    | 0811103 | ??    |   19 | ?    | ????   |      1 |
    | 0811104 | ???   |   20 | ?    | ????   |      1 |
    | 0811109 | abcd  | NULL | ?    | NULL   |      1 |
    | 0811191 | ??    |   18 | ?    | ????   |      1 |
    | 0821101 | ??    |   19 | ?    | ?????  |      1 |
    | 0821102 | ??    |   20 | ?    | ?????  |      1 |
    | 0821103 | ??    |   23 | ?    | ?????  |      1 |
    | 0822201 | abcd  |   22 | NULL | NULL   |      1 |
    | 0831101 | ???   |   22 | ?    | ?????  |      1 |
    +---------+-------+------+------+--------+--------+
    11 rows in set (0.00 sec)

    mysql> select * from student;
    +---------+--------+------+------+--------+--------+
    | sno     | sname  | sage | ssex | dept   | is_del |
    +---------+--------+------+------+--------+--------+
    | 0811101 | ??     |   20 | ?    | ????   |      0 |
    | 0811102 | ??     |   19 | ?    | ????   |      1 |
    | 0811103 | ??     |   19 | ?    | ????   |      1 |
    | 0811104 | ???    |   20 | ?    | ????   |      1 |
    | 0811109 | abcd   | NULL | ?    | NULL   |      1 |
    | 0811191 | ??     |   18 | ?    | ????   |      1 |
    | 0821101 | ??     |   19 | ?    | ?????  |      1 |
    | 0821102 | ??     |   20 | ?    | ?????  |      1 |
    | 0821103 | ??     |   23 | ?    | ?????  |      1 |
    | 0822201 | xiugai |   22 | NULL | NULL   |      1 |
    | 0831101 | ???    |   22 | ?    | ?????  |      1 |
    +---------+--------+------+------+--------+--------+
    11 rows in set (0.00 sec)

    mysql>
可重复读：
        mysql> select * from student;
    +---------+--------+------+------+--------+--------+
    | sno     | sname  | sage | ssex | dept   | is_del |
    +---------+--------+------+------+--------+--------+
    | 0811101 | ??     |   20 | ?    | ????   |      0 |
    | 0811102 | ??     |   19 | ?    | ????   |      1 |
    | 0811103 | ??     |   19 | ?    | ????   |      1 |
    | 0811104 | ???    |   20 | ?    | ????   |      1 |
    | 0811109 | abcd   | NULL | ?    | NULL   |      1 |
    | 0811191 | ??     |   18 | ?    | ????   |      1 |
    | 0821101 | ??     |   19 | ?    | ?????  |      1 |
    | 0821102 | ??     |   20 | ?    | ?????  |      1 |
    | 0821103 | ??     |   23 | ?    | ?????  |      1 |
    | 0822201 | xiugai |   22 | NULL | NULL   |      1 |
    | 0831101 | ???    |   22 | ?    | ?????  |      1 |
    +---------+--------+------+------+--------+--------+
    11 rows in set (0.00 sec)

    mysql> commit;
    Query OK, 0 rows affected (0.00 sec)

    mysql> select * from student;
    +---------+----------+------+------+--------+--------+
    | sno     | sname    | sage | ssex | dept   | is_del |
    +---------+----------+------+------+--------+--------+
    | 0811101 | ??       |   20 | ?    | ????   |      0 |
    | 0811102 | ??       |   19 | ?    | ????   |      1 |
    | 0811103 | ??       |   19 | ?    | ????   |      1 |
    | 0811104 | ???      |   20 | ?    | ????   |      1 |
    | 0811109 | abcd     | NULL | ?    | NULL   |      1 |
    | 0811191 | ??       |   18 | ?    | ????   |      1 |
    | 0821101 | ??       |   19 | ?    | ?????  |      1 |
    | 0821102 | ??       |   20 | ?    | ?????  |      1 |
    | 0821103 | ??       |   23 | ?    | ?????  |      1 |
    | 0822201 | xiugai00 |   22 | NULL | NULL   |      1 |
    | 0831101 | ???      |   22 | ?    | ?????  |      1 |
    +---------+----------+------+------+--------+--------+
    11 rows in set (0.00 sec)

命令行中串行化的隔离级别
    mysql> use s_t;
    Database changed
    mysql> set autocommit=0;
    Query OK, 0 rows affected (0.00 sec)

    mysql> set tx_isolation='SERIALIZABLE';
    Query OK, 0 rows affected (0.00 sec)

    mysql> begin;
    Query OK, 0 rows affected (0.00 sec)

    mysql> select * from student;
    +---------+---------+------+------+--------+--------+
    | sno     | sname   | sage | ssex | dept   | is_del |
    +---------+---------+------+------+--------+--------+
    | 0811101 | ??      |   20 | ?    | ????   |      0 |
    | 0811102 | ??      |   19 | ?    | ????   |      1 |
    | 0811103 | ??      |   19 | ?    | ????   |      1 |
    | 0811104 | ???     |   20 | ?    | ????   |      1 |
    | 0811109 | abcd    | NULL | ?    | NULL   |      1 |
    | 0811191 | ??      |   18 | ?    | ????   |      1 |
    | 0821101 | ??      |   19 | ?    | ?????  |      1 |
    | 0821102 | ??      |   20 | ?    | ?????  |      1 |
    | 0821103 | ??      |   23 | ?    | ?????  |      1 |
    | 0822201 | xiui009 |   22 | NULL | NULL   |      1 |
    | 0831101 | ???     |   22 | ?    | ?????  |      1 |
    +---------+---------+------+------+--------+--------+
    11 rows in set (8.04 sec)

```

## 学生管理系统书写

```java
项目分层：
	pojo:实体类
	dao：java操作数据库
	util：工具
	view:视图，菜单展示
	test:测试代码书写位置
	service：业务逻辑层（不是把数据库中的数据拿到后直接进行的使用，需要进行逻辑判断）
	
项目功能：
   查询：
   添加：注意学号是否存在，判断存在的方式
   修改：判断学生信息是否存在
   删除：逻辑删除和物理删除     
==========》jdbc项目，io项目
        显示=======》都在控制台
        ====》京东=====》控制台======》图片=======》
        =========》数据显示，效果好看
```

## 数据显示=============》前端

```html
浏览器进行数据的展示======》
前端：html
浏览器，一个软件，软件可以识别文件，不同的软件可以打开不同的文件
例如：
	txt：记事本软件
	word：word软件
	java：idea
================》不同的软件可以打开不同的文件
	浏览器中，打开的文件的类型，html的文件类型

创建html的文件，进行编辑
	文件不同，书写的规则不同
	java，
	word
	excel
	ppt：
html：超文本（除了文本，还有图片 视频信息的显示） 标记（标签进行标记） 语言：书写的遵循自己的书写规则
	html书写规则：通过标签进行的书写
	<!doctype>   文档类型 h5
	<html>==============》开始标签
		分为两部分
        <head>
            =======>头部内容，页面的相关配置信息  编码集
            编码集的配置：
            <meta charset="utf-8"/>==========> 自闭和标签
            <title>标题</title>
        </head>
        <body>
            =======>再也面中显示的内容
            fjdkfjdk
        </body>
	</html>=============》结束标签
	
=========》前端书写 使用hbuilder软件=========》
	解压，---------》hbulder.exe 发送到桌面快捷方式========》暂不登录

只要再页面中进行数据显示，都需要通过标签进行展示，
	不同的标签有不同的功能，不同的标签有不同的属性
	a标签： 实现页面的跳转 借助于href属性  
	target：打开位置，默认再当前窗口打开，_blank 空白窗口打开
	<a target="_blank" href="http://www.baidu.com">百度一下</a>
	数据显示，如果显示内容的窗口放不下内容，进行换行
	a标签特点：==============================》一大类的标签
		标签可以再同一行上，宽度随着内容的多少进行改变(不可以设置宽高)
		<!--加粗  -->
		<b>fjdfkjdkfjd</b>
		<strong>fjdkfkdjf</strong>

	html中的标签可以嵌套使用
	<b><a href="http://www.baidu.com">fdjf</a></b>
		倾斜标签
	<i>fjdkfjkdf</i>
		<!--普通文本的显示-->
	<span>jfdkjfdk</span>

	div=======================》一大类的标签
	特点：默认占满一行的标签，（不能和其他标签再同一行上） ，可以设置宽高
		<div>jfdkfjkdjfkd</div>

	<p>fjdkfjkd</p>
	标题标签： 字号从大到小
		<h1>h1</h1>
		<h2>h1</h2>
		<h3>h1</h3>
		<h4>h1</h4>
		<h5>h1</h5>
		<h6>h1</h6>
	
	列表
		有序列表：
		<!--相同信息的列表-->
		<!--有序列表-->
		<ol type="a">
			<li>fj</li>
			<li>fj</li>
			<li>fj</li>
			
			<li>fj</li>
			<li>fj</li>
		</ol>
		无序列表：
		<ul type="square">
			<li>fj</li>
			<li>fj</li>
			<li>fj</li>
			
			<li>fj</li>
			<li>fj</li>
		</ul>
		自定义列表：
		<dl>
			<dt>标题</dt>
			<dd>内容</dd>
			<dd>内容</dd>
			<dd>内容</dd>
		</dl>

	表格：table
	<!--表格居中-->
		<table border="solid" align="center">
			列名=======》标题
			表中内容====》数据
			<thead>
				<caption>值日表</caption>
				<tr>
					<th>星期一</th>
					<th>星期二</th>
					<th>星期三</th>
					<th>星期四</th>
					<th>星期五</th>
				</tr>
			</thead>
			<!--tr中数据居中-->
			<tbody align="center">
				<tr>
					<td rowspan="2">1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
					<td>5</td>
				</tr>
				<tr>
					<td>1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
					
				</tr>
				<tr>
					<td colspan="2">1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
					
				</tr>
				<tr>
					<td>1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
					<td>5</td>
				</tr>
				<tr>
					<td>1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
					<td>5</td>
				</tr>
			</tbody>
		</table>

	td th和div不相同==================》第三类，可以设置宽高，可以再同一行上
		可以再同一行上，手动设置宽度和高度，不随着标签中内容的多少进行改变
	<td width="200" height="100" rowspan="2">1</td>

	图片标签：
	<!--图片 哪个图片
			src：指定图片位置
			title:图片提醒信息
			alt:图片没有显示，信息提醒
			width:宽度
			height:高度
		-->
		<img src="img/cc63ba625ddb9627.jpg.webp"
			title="图片信息"
			alt="提示"
			width="100"
			height="200" />

	视频标签
			<!--mp4 
				src：视频位置
				controls控制条
				autoplay：自动播放
				loop:循环播放
				width
				height
			-->
			<video src="" controls="controls"
				autoplay="autoplay"
				loop="loop"
				width="100"
				height="200"
				></video>

	音频标签：
				src：视频位置
				controls控制条
				autoplay：自动播放
				loop:循环播放
		<audio src="" controls="controls"
				loop="loop" autoplay="autoplay"
				></audio>

form表单
		<!--表单提交的地址 如果不写，默认提交到当前地址-->
		<!--action="index.html"-->
		<form >
			<!--input属性不同，输入的数据不同
				readonly:只读
				hidden="hidden" 隐藏
				required="required" 一定要输入值
				type="number" min="0" max="10" step="2" 
				placeholder="输入用户名" 提醒
				value:input中的值就是value
				name:名字
			-->
			<!--输入的信息进行展示  例如：登录 用户名-->
			<input type="text" value="jfkd" name="username" placeholder="输入用户名"/>
			<!--输入的信息进行密文显示  例如：登录 密码-->
			<input type="password" required="required" name="pwd" />
			<!--日期的选择 输入-->
			<input type="date" name="date" />
			<!--日期 和 时间的选择 输入-->
			<input type="datetime-local" />
			<!--进行数字的输入-->
			<input type="number" name="number" min="0" max="10" step="2"  />
			<!--邮箱输入-->
			<input type="email" name="email" />
			
			<!--单选框
				选框成为一组 name值相同
			-->
			<label>
				<!--字和框成为一组-->
				男：<input type="radio" value="男" name="sex" />
			</label>
			
			女：<input type="radio" name="sex" value="女" />
			
			
			<!--复选框-->
			
			sing:<input type="checkbox" value="f" name="a" />
			run:<input type="checkbox" name="a" />
			read:<input type="checkbox" name="a" />
		
			<!--地址选择-->
			<select name="add">
				<option value="1">1</option>
				<option value="2">2</option>
				<option selected="selected" value="3">3</option>
				<option value="5">4</option>
				<option value="6">5</option>
			</select>
			<!--按钮类型-->
			<!--表单中的数据进行提交，提交到指定地址-->
			
			<input type="submit" />
			<!--已input 的name属性的值作为key
				input框中的数据作为value
			-->
			<input type="reset" />
			
			<input type="button" value="提交" /><br />
			
			<!--文件上传
				图片 多图片
			-->
			<input type="file" multiple="multiple" />
		</form>

```

# day9

## 标签分类

```html
a标签相同特征：（一行内可以放多个元素）======》行内元素
	可以在同一行上，宽度随着内容的改变而改变，不可以设置宽高===========》
	
img input  td------------------------------》行内块元素
	可以在同一行上，可以设置宽高============》

div========（自己是一个整体）=============》块级元素
	默认占满一行，可以设置宽高============================》

html：通过标签进行内容展示的语言，
	在html中，写了什么标签，页面中就显示什么======》html主要功能就是进行页面内容的显示
===========》问题：
	已标签固定的形式进行显示，但是不好看

html中的标签，已指定的方式进行显示
例如：
	生活中，人，--------》化妆
			html=====》样式，已什么方式进行显示  样式，在前端中 css
			（书写顺序，先html后css）
```

## css

```css
书写位置：
	样式就是风格：style
	每个标签都有一个style的属性
css 书写位置，
	style属性中
	<a href="" style="width: 400px;height: 300px;border: solid 1px red;">fdjkfjdkfj</a>
	<div style="width: 300px;height: 200px;border: solid 1px black;">fjdkfj</div>

多个标签需要有相同的样式，
	相同的样式，重复多次出现，（代码冗余）=======》实现一次书写，多个使用
		样式提取，写到style标签中，相同的class名称或者标签名相同
		<div style="width: 300px;height: 200px;border: solid 1px black;">fjdkfj</div>
		<div style="width: 300px;height: 200px;border: solid 1px black;">fjdkfj</div>
		<div style="width: 300px;height: 200px;border: solid 1px black;">fjdkfj</div>
		<div style="width: 300px;height: 200px;border: solid 1px black;">fjdkfj</div>
		<div style="width: 300px;height: 200px;border: solid 1px black;">fjdkfj</div>
		<div style="width: 300px;height: 200px;border: solid 1px black;">fjdkfj</div>
style标签===================》推荐先放在style标签中
	<style>
		/*要给标签设置的样式
				 	样式和标签进行了分离，建立标签和样式的关系
				 	在style标签中，选择标签=====》选择器
				 * id选择器：id唯一标识 id不能重复(js 前端编程)
				 * 标签中，需要有id的属性,
				 * css中选择器的书写  #id值 例如：#di
				 * 
				 * class 选择器，可以选中多个，可以重复
				 * 标签中 class属性
				 * css 中class选择器  .class值 
				 * 
				 * 标签选择器   通过标签名进行的选择
				 * css中通过标签选择器进行标签选择  例如：div
				 * 
				 * 
				 * */
			#a1{id选择器
				width: 300px;
				height: 200px;
				border: solid 1px black;
			}
			
			.t{class选择器
				width: 300px;
				height: 200px;
				border: solid 1px red;
			}
			p{标签选择器
				width: 500px;
				height: 100px;
				border: solid 1px green;
			}
			
			
		</style>
	标签：
		<div id="a1">1</div>
		<div class="t">1</div>
		<div class="t">1</div>
		<!--<p class="t">1</p>-->
		
		<p>fdfdf</p>
css文件中（css样式比较多，可以进行提取，实现多个文件中样式的复用）
	style标签中的样式，进行提取，css文件中
	建立css文件和html之间的关系
	<link rel="stylesheet" href="css/index3.css" />

同一个标签在style属性中，style标签中，css文件中，同时给一个属性设置样式，哪个样式生效？
	书写位置，哪个位置的优先级高？？？？？？？？？？、
	优先级就近原则，哪个样式离着标签进，哪个样式生效

优先级：
	单个选择器  
		id选择器 > class选择器 > 标签选择器
		给一个标签设置多个选择器，哪个选择器样式生效，哪个的优先级高
		<div class="t" id="a1">1</div>
	复合选择器（多个选择器进行组合，进行标签的指定）
```

## css常用的样式

```css
1 宽度和高度
	width:
	height:
2 显示更明显，border 边框
	/*复合样式 线形 宽度 颜色*/
    /*border: solid 2px red;*/
    /*
    一个参数 四个边都是这个参数
    两个参数 第一个上下 第二个 左右
    * 三个参数  第一个上 第二个 左右 第三个是下
    * 四个参数  第一个上 第二个 右 第三个是下 第四个是左
    * */
    /*border-width: 1px 10px 5px 8px;
    border-style: dotted solid dashed double; 
    border-color:red black blue green;*/
    /*样式复合*/
    border-top: solid 2px blue;
    border-bottom: solid 2px blue;
    border-right:  solid 2px blue;;
    border-left:  solid 2px blue;;
    /*拆开*/
    /*border-top-color: green;
    border-top-style:dotted ;
    border-top-width: 30px;*/
	圆角显示：
	border-radius: 10px;

3 背景样式 background
	/*背景颜色*/
    /*background-color: gray;*/
    /*背景图片
    图片填充一个元素
    * 1 图片小，元素大，平铺
    * 2 元素小，图片大，只能显示图片的一部分
    * */
    background-image: url(img/cc63ba625ddb9627.jpg.webp);
    /*横向和纵向都不重复*/
    background-repeat: no-repeat;
    /*x轴平铺*/
    /*background-repeat: repeat-x;*/
    /*y轴平铺*/
    /*background-repeat: repeat-y;*/

    /*调整图片的大小*/
    /*background-size: 830px  822px;*/

    /*图片在元素有自己的位置*/
    /*background-position: center;*/
    /*background-position:center right ;*/
    /*background-position:100px 300px;*/
    /*渐变色*/
    background: linear-gradient(0deg,black,red);

4 字体样式
	/*字体相关  font*/
    /*字体设置*/
    font-family: "microsoft yahei";
    /*字体的大小，字号*/
    font-size: 20px;
    /*进行字体加粗和变细*/
    font-weight: 100;
    /*倾斜*/
    font-style: italic;

    /*字体颜色*/
    color: red;

5 多个字放到一起，----------》文本
	text
    /*没有下划线  none*/
    /*商品价格   原价 删除线  现在价格 删除线line-through*/
    /*下划线 underline*/
    /*上划线 overline*/
    text-decoration:  overline;

	/*元素中的内容 实现水平方向的居中
    元素中的文字和图片实现水平居中
    * */
    text-align: center;
    /*实现竖直方向的居中*/
    line-height: 50px;

	首行缩进
	/*text-indent: 20px;*/

	省略号效果书写：
    /*省略号效果
    单行数据的省略号效果
    * 
    * */
    width: 230px;
    height: 17px;
    border: solid 1px red;
		超出部分隐藏
    overflow: hidden;
	/*遇到空白不换行*/
    white-space: nowrap;
    text-overflow: ellipsis;

    /*多行数据省略号的效果*/
    width: 230px;
    height: 61px;
    border: solid 1px red;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
	
网址：
	https://www.w3school.com.cn/
```

# day10

## 边距

```
html：通过标签进行的页面中内容的展示
	==============》对于html来说，所有的都是标签、
css：对于标签专门的称呼
	==============》 盒模型 盒子====》盒子
	border   内边距（当前元素和内部元素的距离）  实际书写的内容
例如：
	买电脑：
		盒子
```

![盒模型](C:\Users\Tly\Desktop\盒模型.png)

```css
内边距：padding（自己和内部元素的距离）
		/*外部的标签  wrap 内部img 和content*/
				/*如果控制当前元素和内部元素之间的距离
				=======>内边距
				
				* 可以通过外层的盒子的内边距进行调整
				* 外层标签，当前元素的内边距进行调整
				* */
				padding-left: 20px;
				padding-right:200px;
		设置不同个数的参数
				一个参数：四个内边距
				两个参数：第一个上下，第二个是左右

外边距： margin（自己和别人的距离）
	盒子与盒子之间的距离，称为外边距
	/*当前元素和外层元素之间的距离==》外边距
				 * 1 有包含关系的元素
				 * 2 平级元素
				 * */
				
				margin: 20px;
	外边距，在竖直方向上，进行合并
	content ====>margin:20
	price=========margin:50
====================>竖直方向上的距离 50px
	水平方向上的外边距会不会合并？
	元素放到同一行上，才能看外边距是否合并？
	==========================》水平方向的外边距不会合并
	元素：可以设置宽高，又可以在同一行上的元素=========》行内块元素
```

## 页面布局

```css
css中的样式：
	实现元素的类型之间的转换：
	行内元  inline素，行内块元素inline-block，块级元素 block
	display: inline-block;

有一些标签有默认的内边距和外边距，影响到我们通过自己的数据进行值得设置
	=========》统一的把所有元素得边距去除，根据自己得场景进行边距得设置
	*{ 选中所有得标签进行样式得设置 ==========》（优先级比较低）
				margin: 0px;
				padding: 0px;
			}
	页面布局查看，当前元素占用得空间
<!--外层添加固定大小得元素，元素不会随着窗口得变化
			而变化-->

进行页面布局时，可以搭建一个样式，然后复制，需要修改每个元素得内部得内容
选择器：nth-child(数字){
    
}
复合选择器：（以后搭建页面复杂，使用复合选择器）
	多个选择器组合在一起进行元素得指定
	父子选择器：
		父元素 空格 子元素
	.wrap:nth-child(2) .img{
				background-image: url(img/f172076a2d8c7c5e.jpg.webp);
			}

display 进行了页面布局，
	问题：每个元素之间都有一个间距
		只能从左向右排列

项目时间比较长，页面布局使用float	
浮动，float
	实现方式，元素成为行内块，
	浮动得元素之间没有空白间距
	而且可以左浮动也可以右浮动

html得页面，加载时有顺序得，从上到下依次加载===========》流式加载
如果外层元素没有设置高度，由于内部元素得高度，外层得元素被内部元素撑开

浮动自己得特点：
	给哪个标签进行页面布局，给谁加浮动float
	添加了浮动得效果，========》浮动实现脱离文档流的特征（z轴和其他元素不在同一个值）
=======》浏览器 是一个有x轴和y轴的一个坐标系
=======》不是平面的结果，是一个3d结构，z轴（垂直于屏幕）

实现回到文档流的效果
	清除浮动（使用浮动的效果，回归到文档流中）
	浮动的元素 平级的的位置上 最后的位置上 空标签


css3 =========>布局  弹性布局
	弹性 盒子=======》弹性分布
	根据放入的元素，进行父级元素空间的分配
	弹性布局：
	书写的位置：父级元素中
	#outer{
				width: 1280px;
				height: 1000px;
				border: solid 1px red;
				/*父级元素成为一个弹性盒子*/
				display: flex;
				/*弹性盒子中的水平方向上空白进行分布*/
				/*justify-content: space-around;*/
				justify-content: space-between;
				/*弹性盒子中的元素 默认不换行*/
				/*样式实现换行*/
				flex-wrap: wrap;
				/*竖直方向进行间距的分配*/
				align-content: space-between;
			}

元素展示时，水平方向上进行居中
	当前元素中文本或者图片进行居中=========》text-align

margin：auto:实现元素的居中
	块级元素可以在另一个块级元素中水平居中
	.test{
				width: 100px;
				height: 80px;
				border: solid 1px black;
				margin: auto;
			}
	<div class="wrap">
        <div class="test">jfkdjf</div>
     </div>


	#di{
				width: 1200px;
				height: 500px;
				border: solid 1px red;
				display: flex;
				justify-content: space-around;
			}
			.test{
				width: 200px;
				height: 200px;
				background-image: url(img/cc63ba625ddb9627.jpg.webp);
				background-size: 200px 200px;
			}
	<div id="di">
			<div class="test"></div>
		</div>



垂直居中
	line-height:文字在当前块级元素中进行居中

块级元素，在另一个块级元素中进行居中
		#di{
				width: 1200px;
				height: 500px;
				border: solid 1px red;
				display: flex;
				justify-content: space-around;===》水平方向的居中
				align-items: center;===========》内部元素竖直方向的居中
			}
			.test{
				width: 200px;
				height: 200px;
				background-image: url(img/cc63ba625ddb9627.jpg.webp);
				background-size: 200px 200px;
			}

进行页面布局：
	分析页面的结构
		主要功能
		秒杀
	根据页面中功能不同进行页面结构的搭建
```

## css中动态效果

```css
伪类：hover鼠标放上的时机

/*伪类选择器*/
    .t:hover{
        width: 1000px;
        
        过渡  哪个样式进行过渡  过渡时间  延迟时间
        transition: width 10s  1s;
    }

/*动态效果   动画 需要我们自己定义
			 动画定义后不能执行，
			 * 相当于调用，才能执行
			  * 动画的定义和执行，考虑到浏览器的兼容性
			 * */
			@keyframes test{
				from{
					/*开始的状态*/
					width: 100px;
				}
				to{
					/*结束的状态*/
					width: 1200px;
				}
			}
			@-webkit-keyframes test{
				from{
					/*开始的状态*/
					width: 100px;
				}
				to{
					/*结束的状态*/
					width: 1200px;
				}
			}
			@-moz-keyframes test{
				from{
					/*开始的状态*/
					width: 100px;
				}
				to{
					/*结束的状态*/
					width: 1200px;
				}
			}
			@-ms-keyframes test{
				from{
					/*开始的状态*/
					width: 100px;
				}
				to{
					/*结束的状态*/
					width: 1200px;
				}
			}
			@-o-keyframes test{
				
			}
			
			.t:hover{
				/*动画执行*/
				animation: test 1s;
				-webkit-animation: test 1s;
				-moz-animation: test 1s;
				/*动画执行，只是把效果执行，结束状态不会进行保存*/
				/*如果动画结束状态进行保留*/
				/*动画执行时,结束状态进行修改*/
				width: 1200px;
			}
			
整个的动画效果拆分，一个整体，从0%到100%
	@keyframes test{
				0%{
					width: 100px;
				}
				1%{
					width:200px ;
				}
				50%{
					width: 300px;
				}
				100%{
					width: 1300px;
				}	
				
			}
			
=======================》页面布局，动态效果
定位，3D 
```

# day11

## 定位

```css
效果：
	鼠标放上，显示一个div，如果鼠标不放上，div不显示
	=========》div 一开始是隐藏得，鼠标放上，可以进行显示
	=====================》使用伪类hover鼠标放上进行操作
	/*实现当前元素得隐藏   而且 不占位得隐藏*/
    /*display: none;*/
    /*实现当前元素得隐藏   而且 占位得隐藏*/
    /*visibility: hidden;*/
	
	div叠加在另一个div上进行得显示-------》z轴上得值不一样，脱离文档流
	（页面布局，流式布局，从上到下进行得加载）-------》
	position  css中得定位
	定位:固定位置
	/*默认得定位*/
				
    /*position: static;*/
    /*除了默认得定位，其他得定位方式，
    有两个样式生效  left   top  (right  bottom)
    * */


    /*相对定位  相对于谁进行定位
    相对于自己原来得位置进行定位
    * */
    /*position: relative;*/


    /*绝对定位  页面中得位置

    * 位置找包含自己最近一层得元素
    * 1 如果这个元素定位了,当前元素得位置,相对于这个已经定位得元素
    * 2 如果包含自己得元素没有定位得,相对于浏览器进行定位
    * 
    * 
    * */
    position: absolute;
    left: 0px;
    top: 0px;

	/*忽略滚动条得定位
    当前元素得位置和滚动条没有关系
    * */
    position: fixed;
		===========》定位方式
```

## 3D效果

```css
牙膏，盒子，长宽高
	========》六个面
<style>
			div{
				width: 200px;
				height: 200px;
				border: solid 1px red;
				position: absolute;
				left: 0px;
				top: 0px;
			}
			#di{
				width: 200px;
				height: 200px;
				border: solid 1px red;
				position: absolute;
				left: 0px;
				top: 0px;
				/*3d场景*/
				transform-style: preserve-3d;
			}
			#wrap{
				/*镜头*/
				width: 200px;
				height: 200px;
				border: solid 1px red;
				perspective: 800px;
				position: absolute;
				left: 400px;
				top: 300px;
			}
			#di .left{
				transform: translateX(-200px) rotateY(90deg);
				/*旋转轴*/
				transform-origin: right;
			}
			#di .right{
				transform: translateX(200px) rotateY(-90deg);
				/*旋转轴*/
				transform-origin: left;
			}
			#di .top{
				transform: translateY(-200px) rotateX(-90deg);
				/*旋转轴*/
				transform-origin: bottom;
			}
			#di .bottom{
				transform: translateY(200px) rotateX(90deg);
				/*旋转轴*/
				transform-origin: top;
			}
			#di .front{
				transform: translateZ(200px);
			}
			
			#di:hover{
				transform: rotateY(180deg);
				transition: 5s;
			}
			
		</style>
	</head>
	<body>
		
		<!--
			1 镜头(和场景分离)
			2  场景
			
		-->
		<div id="wrap">
			<div id="di">
				<div class="left"></div>
				<div class="right"></div>
				<div class="front"></div>
				<div class="after"></div>
				<div class="top"></div>
				<div class="bottom"></div>
			</div>
		</div>	
	</body>
```

## 总结：

```css
1 css 书写位置
2 优先级
3 选择器 及优先级
4 常用样式   1 单个元素得样式  文本 图片  2 多个元素之间得样式 边距
5 页面布局  display   浮动  弹性布局
6 元素之间得叠加   定位
7 3D 案例
```

## javascript（前端编程语言）

```js
前端进行编程，
	判断条件
	网址注册：根据输入得数据进行用户名判断
	登录：用户名 密码，提示

前端：html + css + js（javascript）

语言分类：
java 编程语言：
	强类型语言（定义时指定数据类型，而且在使用过程中，数据类型不能更改）
	解释型语言：一定要有解释器（JVM）
	编译型语言：形成新得文件，java====》class

js:
	弱类型语言：定义时不用指定数据类型，而且使用得过程中，类型可以修改
	解释型语言：解释器（在浏览器中，js执行得解释器）
    
js得代码书写位置：
	1 <script>标签 书写js得代码
    一般情况下，<script>标签写在html得末尾

    2 js文件中
	
 java 语言基础和语言特性
 js 语言基础和语言特性
 
 js语言基础：
 	常量 
    变量 值可以改变
    变量得数据类型
    	//js中控制台输出
         console.log(1.5)
        //js中,通过var关键词进行得变量得定义
        var a = 1;
        console.log(a)
        //js 关键词 typeof 查看变量得数据类型
        //数字(整数和小数)  number类型
        //单引号和双引号引起得数据 都是字符串 string类型
        //true 和false boolean类型
        //变量没有定义,undefined类型
        // 特殊类型 null
        // object类型
        console.log(typeof a)
        a=1.555
        console.log(typeof a)
        a="fjdkf"
        console.log(typeof a)
        a=true
        console.log(typeof a)

        console.log(typeof b)
        console.log(typeof null)
运算符：
	结果是数字得运算符
    	算术运算符 + - * / %
			var a= 10;
			var b = 40;
			console.log(a+b)
			console.log(a-b)
			console.log(a*b)
			console.log(a/b)
			console.log(a%b)

        赋值（复合运算符）运算符  += -= *= /= %=
    		var a= 10;
			var b = 40;
			console.log(a+=b)
			console.log(a-=b)
			console.log(a*=b)
			console.log(a/=b)
			console.log(a%=b)
    
		用来标识数字得正负号：+ - 
            
        ++ -- 进行加一减一运算
			符合运算符和变量顺序关系
            ++a 先加后用
            a++ 先用后加
			console.log(++a)

		+ 进行数字和字符串拼接
		console.log(typeof (++a+"fdjkfjd"))    
    
    结果是boolean得运算符
    	关系运算符
        	var a= 10;
			var b = -40;
        	console.log(a>b)
			console.log(a>=b)
			console.log(a<b)
			console.log(a<=b)
			console.log(a==b)
			console.log(a!=b)
		注意：自己特色得运算符：
			//== js中 只进行值得比较 不进行数据类型得比较
			var a = 10;
			var b = "10"
			console.log(a==b)
			//=== js 进行值得比较 进行数据类型得比较
			console.log(a===b)
			
        逻辑运算符  && || ！
        	a<b<c  a<b boolean < 数字c 

        	var a = 10;
			var b = 5;
			var c = 100;
			console.log(a>b&&b<c)
			console.log(a<b||b<c)
			console.log(!(a<b||b<c))
		并且，多个条件同时成立，结果成立，结果false
        或者：只要有一个条件成立，结果成立，否则结果false
        短路效果：运算符连接得表达式前面得可以决定整个表达式得结果，后面得不执行
        	console.log(a<b&&b<c++)
			console.log(c)=========》100

        三元运算符
       	 console.log(a>b?a:b)
        
   通过js中提供得方法进行运算
   			console.log(a<b<=0)========>true
			//true 对应数字 1
			//false 对象数字 0
			console.log(Number(true))
			console.log(Number(false))
    
			//NaN   not a number 不是一个数字
			console.log(Number("fdjkfjd"))
			console.log(Number("123fdjkfjd"))
			console.log(Number("12345"))--------》转换数字格式得字符串
   			 //转换得字符串都是字母,结果NaN
			console.log(parseInt("jfkdjf"))
			console.log(parseInt("121jfkdjf"))
			console.log(parseInt("1234"))
    
 			Number 方法进行数字和字母组合，进行得转换，结果是NaN，
            	进行boolean转换，true是1 false 是0
            parseInt()/parseFloat() 进行数字和字母组合，进行转换，结果前面得数字
            	进行boolean转换，结果是NaN
 
   字符串和数字转成boolean类型
   		console.log(Boolean(0))
		Boolean可以把数字和boolean进行转换，非0数字转成是true ，0转成false
        
        console.log(Boolean(""))
         Boolean可以把字符串和boolean进行转换，非空数字转成是true ，空转成false
            
流程控制语句
	分支语句
    if
    if(){}else{}    
	if(){} else if(){}........
    	var s = 100;
			var t = 100;
			if(s>t){
				console.log(s)
			}else if(s<t){
				console.log(t)
			}else{
				console.log("====")
			}

    循环语句


```

# day12

## 接上

```js
流程控制语句
	分支语句
    if分支
    if
    if(){}else{}    
	if(){} else if(){}........
    	var s = 100;
        var t = 100;
        if(s>t){
            console.log(s)
        }else if(s<t){
            console.log(t)
        }else{
            console.log("====")
        }

	switch case 分支
		var a = 1;
			switch (a){
				
				case 1:
					console.log(1)
					
				case 2:
					console.log(2)
					break;
				case 3:
					console.log(3)
					break;
				case 4:
					console.log(4)
					break;
				default:
					console.log("没有匹配项")
					break;
			}
        执行时，先匹配case中得值，如果没有匹配项，执行default中得代码
        default可以放在任意位置，一般放在末尾
        case default 结束时需要加break，否则case穿透
                    
        switch（数据类型，number，string ，boolean，null）
        进行数据类型和值得比较=============================》
            
    循环语句
		for
         for(var i =0;i<=10;i++){
				console.log(i)
			}
			//变量作用域 
			console.log("======")
			console.log(i)           
            // var 定义得变量，出现作用域泄露问题      
            // let 定义变量  
            for(let i =0;i<=10;i++){
				console.log(i)
			}
             出了循环，不能使用
            // 定义常量
             const s = 100;
			s=200;================》出错，常量得定义，一旦定义，值不能修改
			console.log(s)
                    
        ===========不要再浏览器中书写死循环，导致页面一直加载         
        while
           var t = 1;
			while(t<10){
				console.log(t)
				t++;
			} 
               
		do while，至少执行一次
```

## 常用得数据类型

```js
js中得方法：
	需要有两个流程
    1 先定义方法
    2 执行进行方法得调用
	//实现两个数相加
    	定义方法
			function add(){
				console.log("add执行了。。。。")
			}
		调用方法	
			add()

		有参方法的定义和调用
        function add(){
				console.log("add执行了。。。。")
			}
			
        add()

        function add(a,b){---------》参数不用写var，直接写参数列表即可
            console.log(a+b)
        }
        add(3,6)
		add() 结果 NaN   add(3,6) 结果9
		注意：js中没有方法重载，一个script表中，只要定义了相同名称的方法，后一个就会把
        前面的方法覆盖
        
        模拟js可以接收不同个数的参数
        function add(a,b,c){
				//方法中专门有一个变量进行参数的存储
				//arguments 变量 其实是一个数组
				if(arguments.length==1){
					console.log(arguments[0])
				}else if(arguments.length==2){
					console.log(arguments[0]+arguments[1])
				}else if(arguments.length==3){
					console.log(arguments[0]+arguments[1]+arguments[2])
				}
				
			}
		add(1,10,100)

        方法有返回值和无返回值的方法
        function test(a){
				return a*10;============》return 方法有返回值的方法
			}
			
        var result = test(10)
        console.log(result)
        
		console.log(typeof test)=========》function类型

		var a = 100;
		var test = function(){
            方法的逻辑
        }
        
        test()
		var方式定义方法，先定义，后调用（使用变量是一样的顺序）
        function定义时，调用时位置任意（优先加载）
        注意：const 变量定义成常量，常量值不能修改，（不能重复赋值）
        
数字，
	运算：运算符，方法
    Number() 
	parseInt()

    方法可以提供不同得功能进行运算，Math
    
    console.log(Math.PI)
    console.log(Math.floor(9.9))
    console.log(Math.ceil(9.1))
    console.log(Math.sqrt(9))
    console.log(Math.pow(3,3))
    console.log(Math.random())
    console.log(Math.round(4.5))
    console.log(Math.sin(30*Math.PI/180))

字符串类型
	运算：拼接，方法
    	js中字符串的方法，进行字符串操作，使用以下方法完成对应的功能
            var r = "   abcdef   "
            console.log(r.length)
        console.log(r.indexOf("a"))
        console.log(r.lastIndexOf("b"))
        console.log(r.toUpperCase())
        console.log(r.toLowerCase())
        console.log(r.startsWith("a"))
        console.log(r.endsWith("f"))
        console.log(r.replace("a","X"))
        console.log(r.repeat(5))
        console.log(r.trim())
        console.log(r.trimLeft())
        console.log(r.trimRight())
        console.log(r.concat("abc"))

日期类型Date
	Date是一个function的类型
    进行的具有年月日时分秒特征信息的描述
	=========》具有相同特征和行为的一类事物的描述=======》
	js中进行具有相同特征和行为的事物的描述，通过funciton进行的表示
	
    js中通过function进行一类事物的描述
    
    	js中创建对象的第一种方式：
    	//cat一类事物进行的描述
			function Cat(name,type){
				//当前一类事物的特征和方法，
				//创建对象，当前对象（this）的特征和方法
				this.age=1;
				this.name=name;
				this.type=type;
				this.run = function(){
					console.log("run")
				}	
			}
			
			console.log(Date)
			console.log(Cat)//function
			

			//具有相同特征和行为的一类事物进行具体的描述
			==========================》对象进行的信息描述
			var c = new Cat("tomcat","加菲猫");
			console.log(c)
    		//js 特征可以动态的进行添加
			c.color="黑色"
			c.test="jfkd"
			console.log(c)
			
			//特征查看
			for(var a in c){
				console.log(a)
			}
			
			console.log(typeof c)//object类型

    js定义对象的第二种方式：
    	//对象的输出，有固定格式的  
//			{属性名:属性值,属性名:属性值......}======------->json
//			Dog {name: 'abc', age: 2, type: 'test', run: ƒ}
			
			var c1 = {"name":"tomcat","age":2};
			console.log(c1)
    
Date日期
	function进行的定义
    使用方式，通过new的方式进行使用
    var d1 = new Date();
    console.log(d1.getYear())// 1900 到现在的时间间隔
    console.log(d1.getFullYear())
    console.log(d1.getDate())
    console.log(d1.getMonth())// 月份索引0-11
    console.log(d1.getDay())
    console.log(d1.getTime())
    console.log(d1.getHours())
    console.log(d1.getMinutes())
    console.log(d1.getSeconds())
```

## 数组类型

```js
//有自己的长度，通过索引进行的数据获取
		//索引的范围从0到length-1
		//数组中可以放不同的数据类型
			var arr=[1,3,2,43,4,5,4,65,7,767];
			console.log(arr)
			console.log(arr.length)
			console.log(arr[arr.length])//不会报错 undefined
			//数组是否可以进行长度的动态的改变-------》list
			//常用的数组相关的方法
			//添加到数组的末尾  
			arr.push(true)
			//删除最后一个数据
			arr.pop();
			// 删除第一个数据
			arr.shift()
			//添加数据到第一个位置上
			arr.unshift("abc")
			//如果参数有两个，将指定位置上的数据进行删除
			//如果参数多于两个，将指定位置上的数据删除，并且第三个
//			数据开始,进行数据的添加
			arr.splice(1,3,54,43,23,2,43,5,45,7)

			console.log(arr)

			//形成新的数组
			//再原来数组的基础上进行截取
			console.log(arr.slice(1,4))
			//拼接数据
			console.log(arr.concat(3,5,45,45,6))
			//数组转字符串，指定的字符进行分割
			console.log(arr.join("-"))
排序：
	Arrays.sort()
		//java中，拿着一组数，进行排序=======》
			//stream流，sort方法，指定排序规则
			js中，使用sort方法，自己定义比较规则	
			console.log(arr.sort(function(o1,o2){
				return o1-o2
			}))


		//callback 回调函数
			arr.forEach(function(i){
				console.log(i)
			})

	//callback可以进行简化
//			java lambda表达式进行的简化  （）->{}
			//js  简化方式              （）=>{}
			
			arr.forEach((i)=>{
				console.log(i)
			})

		继续简化：
            arr.forEach(i=>console.log(i))
```

## DOM节点

```js
JS中对html中的标签进行操作
	html：所有的内容的展示，通过标签进行的书写
	css:认为html所有的标签都是一个盒子  盒模型
	js:认为html所有的标签都是一个=======dom节点
    
    D====》document，文档，当前整个的html的文件，是一个文档
    O------》js中，表示标签的类型 object
    M======》model ,每个标签，一个模型
    ==============》DOM 文档对象模型

    console.log(document)对象输出，整个html中的标签都可以进行显示
    
    js对dom节点的操作，就是对html中某个标签的操作
    
    对某个标签进行操作，可以再document的对象中进行获取
    获取方式：
    通过id获取：
    	var d = document.getElementById("di")
		console.log(d)

	一个页面中，id不能重复，通过id获取dom节点，只能获取到第一个，不能获取到第二个
    <div id="di">jfdkfj</div>
	<div id="di">1111</div>
    <script>
            var d = document.getElementById("di")
    		console.log(d)	
    </script>
    
	js中获取到dom节点后，可以设置相关的样式：
   			d.style.backgroundColor="red"
			d.style.borderRadius="50px"
			d.style.color="blue"
			d.style.opacity=0.6
			d.style.cursor="pointer"
		这种设置方式，比较麻烦：每设置一个样式，都要写一句样式代码
        如果设置的样式比较多，代码特别长===============
	换一种方式进行书写：
    	d.style="background-color:red;color:blue"
		优点：样式写在一起，
		缺点：都是字符串，没有提示，容易出错，出错了，样式不能生效
```

# day13

## 接上

```js
平时如何给标签设置的样式？
	样式写在css中，通过选择器选中标签，当前样式给指定的标签进行使用
	第三种方式给标签设置样式
    	给标签设置属性
    //上次 比较id和class选择器优先级
    //把css中已经定义好的样式 给定到指定的标签上
    d.setAttribute("class","a")=====》指定设置什么属性名和属性值

	专门给class设置名称的
    	d.className="a"

当前标签设置内容
	一个闭合的标签中，
    	包含文本
        包含标签
        
	//d.innerText 如果赋值，就是设置值
			//如果不赋值，就是获取值

			//给dom节点内部设置了文本信息
	//d.innerText="js中设置的标签文本信息"
			//获取dom节点中的文本信息
			console.log(d.innerText)

	d.innerText="<p>js中设置的标签文本信息</p>"
	只能把当前的p标签认为是文本，不会以标签的方式进行显示，以文本的方式进行的显示
    
    
    通过使用innerHTML查看当前标签中的内容，
    借助于窗口中的source选项卡，通过打断点的方式进行文本内容的查看
    查看其他网站中，资源文件的查看，在source中进行获取
    
    
    d.innerHTML="<p>jfkdjfdkf</p>"
	把标签书写到页面中，信息读取成文本进行显示
    
    innerHTML和innerText区别：
    	text只能获取到文本信息，设置标签中的内容，只能设置文本，
        HTML 获取到文本和标签，符号（\n\t），设置文本和标签

创建dom节点
		//js中创建dom节点 ，添加到页面中	
        var c = document.createElement("div")	
        c.innerText="test data"
        console.log(c)
        //只能拼接成子元素
        d.appendChild(c)
		===========》默认的拼接位置，拼接到末尾的位置上


例如：
	数据的显示  tbody中不知道要显示多少条，所以不能书写tr的个数
    tr只能在js中根据数据的条数进行拼接
    <table>
			<caption>student信息</caption>
			<thead>
				<tr>
					<th>学号</th>
					<th>姓名</th>
					<th>年龄</th>
					<th>其他</th>
				</tr>
			</thead>
			<tbody id="tb">
				<!--数据在js中 在tbody中不知道该写几个tr-->
			</tbody>
		</table>
		
		<script>
			var t = document.getElementById("tb")
			var stus = [];
			//数据进行组合，存储到数组中
			for (var i = 1;i<=5;i++) {
				var stu = {};
				stu.sno="08111"+i
				stu.sname="abc"+i
				stu.age=i
				stu.message="提示"
//				console.log(stu)
				stus.push(stu)
			}
//			console.log(stus)

			//数据灵活的放到tbody
			for(var i = 0;i<stus.length;i++){
				var tr = document.createElement("tr")
				var td = document.createElement("td");
				td.innerText=stus[i].sno
				tr.appendChild(td)
				
				var td1 = document.createElement("td");
				td1.innerText=stus[i].sname
				tr.appendChild(td1)
				
				var td2 = document.createElement("td");
				td2.innerText=stus[i].age
				tr.appendChild(td2)
				
				var td3 = document.createElement("td");
				td3.innerText=stus[i].message
				tr.appendChild(td3)
				
				t.appendChild(tr)
			}	
		</script>	
	</body>
===========================================》

	拼接，只能成为子节点
    但是，指定子节点的位置，哪个标签前面
    var s1 = document.getElementById("s")
	d.insertBefore(c,s1)

已有的元素，进行删除
	// 当前的元素进行删除，如果这个元素中有子元素
	//子元素一起进行删除
	d.remove()

//		指定删除的子元素
		var s1 = document.getElementById("s")
		d.removeChild(s1)

js操作dom节点的流程：（html中操作标签的流程）
	1 需要的位置进行标签的书写
    2 内部是否需要添加标签
    3 设置文本
    4 设置样式
    5 标签进行删除
```

## 节点获取方式

```js
获取节点方式：
	1 通过id进行节点的获取
	document.getElementById();========>只能获取一个元素

	2 通过class属性进行的dom的获取，可以获取到多个
	//			通过class属性进行的dom的获取，可以获取到多个
			var as = document.getElementsByClassName("a")
			console.log(as)
			//通过索引可以获取到指定的元素
			console.log(as[0])
		实现插色显示：
        var d = document.getElementById("di")====》删除一定要获取到父节点
        for (var i = 0;i<as.length;i++) {
				if(i%2==0){
					as[i].style.backgroundColor="red"
				}else{
					as[i].style.backgroundColor="gray"
				}
            if(i==3){//=====删除逻辑
					d.removeChild(as[3])
				}
			}
===================》元素的创建，删除，设置样式，文本操作
	3 通过标签进行元素的获取========》获取到多个
	var divs = document.getElementsByTagName("div")
	console.log(divs)

	var divs = document.getElementsByTagName("div")
			console.log(divs)
			for (var i =1;i<divs.length;i++) {
				if(i%2==0){
					divs[i].style.backgroundColor="red"
				}else{
					divs[i].style.backgroundColor="gray"
				}
				if(i==3){
					divs[0].removeChild(divs[3])
				}
				==========》第四次循环不执行
			}

	4 通过name属性进行的标签的获取====获取到多个
	//通过name属性进行的标签的获取
    var abs=document.getElementsByName("ab")
    console.log(abs)

    var ses = document.getElementsByName("sex")
    console.log(ses)
	//input 输入，选择值   自闭和   value
	//innerText  闭合标签中的文本信息
		console.log(ses[1].value)
案例：
	input 数据的输入是否可以实现
    ==========》注册，用户名如果已经存在，提示用户名已存在
					 用户名不存在，提示用户名可以注册
		<form action="">
			<input type="text" name="username" value="admin" />
			<span id="msg"></span>
		</form>
		<script>
			var user = document.getElementsByName("username")
			var me = document.getElementById("msg")
			if(user[0].value=="admin"){
				me.style.color="red"
				me.innerText="用户已存在，请重新输入"
			}else{
				me.style.color="green"
				me.innerText="用户名可以使用"
			}
		</script>

dom节点的操作：
	1 获取节点的方式：
    	id   class tagName  name
    2 设置样式，设置文本
    	input  ====>value  div类标签  innerText  innerHTML
    3 创建节点，一定要进行元素的添加
    	添加到末尾，添加到指定位置
    4 移除 
    	当前的元素全部移除，移除指定元素
 
 用户名验证案例，输入不能灵活的输入，=========》       
        ----------》js获取到页面中输入的数据
```

## 事件

```js
事件： 页面中一个动作，触发的一个逻辑
页面中的事件：
	1 鼠标
    	当鼠标在页面中进行操作，执行对应的逻辑（方法）
        鼠标，可以进行单击动作，（点击事件）
    	   //单击事件触发，通过鼠标左键的点击实现的
        	事件触发第一种方式：
			var d = document.getElementById("di")
			d.onclick=function(){
				console.log("单击事件发生了")
			}
			事件触发第二种方式：
            <div id="di" onclick="test()">	
			</div>
    		js中定义的方法
    		function test(){
				console.log("单击事件发生了")
			}
		鼠标，可以进行双击事件的触发
        ========》只对鼠标左键的双击生效
        var d = document.getElementById("di")
			d.ondblclick=function(){
				console.log("双击事件发生了")
			}

			//鼠标放上事件onmouseover  onmouseenter
			//鼠标放上的事件
			enter 认为放到自己的元素上，就认为是放上，包括子元素
            over：只有放到自己元素上，才是放上，如果子元素，这个事件继续触发
			var d = document.getElementById("di")
			d.onmouseenter=function(){
				console.log("鼠标enter事件发生了")
			}
			
			var d = document.getElementById("di")
			d.onmouseover=function(){
				console.log("鼠标over事件发生了")
			}

		//鼠标移动事件
		鼠标放到指定元素上，进行了移动，就可以进行事件的触发
			var d = document.getElementById("di")
			d.onmousemove=function(){
				console.log("鼠标移动事件发生了")
			}

		//鼠标离开事件
        //out 如果离开自己放到子元素上，认为鼠标离开事件
        //leave 离开了自己的元素，才认为元素离开
        //如果放到子元素上，子元素是自己的一部分，不认为是离开
        var d = document.getElementById("di")
        d.onmouseleave=function(){
            console.log("鼠标离开事件发生了")
        }
	
		鼠标点击 按下事件和 抬起事件
			//鼠标按下的事件
			var d = document.getElementById("di")
			d.onmousedown=function(){
				d.style.backgroundColor="red"
			}

			d.onmouseup=function(){
				d.style.backgroundColor="green"
			}
	
		滚轮事件的触发
        var d = document.getElementById("di")
			d.onmousewheel=function(){
				console.log("鼠标滚轮事件发生了")
			}

	案例：
    		dom+事件========》计算器
		<form>
			<input type="text" id="data" /><br />
			<input type="button" value="1" onclick="num(1)" />
			<input type="button" value="2" onclick="num(2)" />
			<input type="button" value="3" onclick="num(3)" />
			<input type="button" value="+" onclick="fuhao('+')" /><br />
			<input type="button" value="4" onclick="num(4)" />
			<input type="button" value="5" onclick="num(5)" />
			<input type="button" value="6" onclick="num(6)" />
			<input type="button" value="-" onclick="fuhao('-')" /><br />
			<input type="button" value="7" onclick="num(7)" />
			<input type="button" value="8" onclick="num(8)" />
			<input type="button" value="9" onclick="num(9)" />
			<input type="button" value="*" onclick="fuhao('*')" /><br />
			<input type="button" value="0" onclick="num(0)" />
			<input type="button" value="/" onclick="fuhao('/')" />
			<!--<input type="button" value="c" onclick="cl()" />-->
			<input type="reset" value="c" />
			
			<input type="button" value="=" onclick="eq()" />
		</form>
		<script>
			var dat = document.getElementById("data")
			//数字按钮点击，实现当前数字在输入框中显示
			function num(e){
				//数字显示在输入框中,而且进行数字的拼接
				//input中，数据默认是字符串类型
				dat.value+=e;
//				console.log(typeof e)
//				console.log(typeof dat.value)
			}
			
			var before;
			var fu;
			
			function fuhao(f){
				//输入符号后，需要记录第一个输入的数字
				//继续输入第二个数字 （重新输入）
//				---》input中的数据 临时清空  但是进行记录
				before=dat.value;
				dat.value=""
				fu=f;
			}
			function eq(){
				var after = dat.value;
				switch (fu){
					case '+':
						dat.value=(parseInt(before)+parseInt(after))
						break;
					case '-':
					dat.value=(parseInt(before)-parseInt(after))
						break;
					case '*':
					dat.value=(parseInt(before)*parseInt(after))
						break;
					case '/':
					dat.value=(parseInt(before)/parseInt(after))
						break;
					default:
						break;
				}	
			}
			function cl(){
				dat.value=""
			}
			</script>
	滚轮滚动事件，进行效果的书写
    ==================》滚动到一定位置才进行标签的显示

		//和鼠标相关的事件，鼠标进行操作时，在浏览器中位置的记录
			var d = document.getElementById("di")
			var c = document.getElementsByClassName("a")
			// 参数记录，当前鼠标进行的操作的位置（x,y）
			//浏览器上x和y的位置======》事件句柄
			/*d.onclick=function(e){
				//谷歌浏览器，有clentx +pageX进行的位置记录
				//其他浏览器，只有其中的一种
				console.log("("+e.clientX+","+e.clientY+")")
				console.log("("+e.pageX+","+e.pageY+")")
			}*/
			
			// 实现滚轮滚动到指定位置才进行标签的显示
			d.onmousewheel=function(e){
				if(e.offsetY>=300){
					c[0].style.display="block"
				}else{
					c[0].style.display="none"
				}
				
				console.log(e)
			}	
		</script>

    2 键盘按键
        -----------》查看输入的数据，一定要使用input进行数据的展示
    	按键的按下事件：
    	var d = document.getElementById("di")
			d.onkeydown=function(){
				console.log("按键按下了")
			}

		var d = document.getElementById("di")
			d.onkeypress=function(){
				console.log("按键按下事件")
			}

		按键的抬起事件：
        var d = document.getElementById("di")
			d.onkeyup=function(){
				console.log("按键抬起事件")
			}

	例如，动态获取input中value值
		//注册 动态的在浏览器中进行数据的输入
			//按键事件，获取到input中的value值
			var d = document.getElementById("di")
			d.onkeyup=function(){
				console.log(d.value)
			}

		//一些网站注册时，一边输入一边验证
			var d = document.getElementById("di")
			var m = document.getElementById("msg")
			d.onkeyup=function(){
				var v = d.value
				if(v=="admin"){
					m.innerText=("用户名已存在")
				}else{
					m.innerText=("用户名不存在，可以注册")
				}	
				
			}



例如：
	电脑上游戏
    	如何判断我们输入按键是哪一个？？？？？？？？
		不涉及到数据的显示，判断按下的是哪个键，根据不同的按键的输入，执行不同的操作
        var divs = document.getElementsByTagName("div")
			var width=100;
			document.onkeydown=function(e){
				//e 可以判断输入的按键信息
				if(e.keyCode==65){
					width+=10;
					divs[0].style.width=width+"px"
				}else if(e.keyCode==68){
					width-=10;
					divs[0].style.width=width+"px"
				}

    input中进行输入，用户名输入完毕，光标不在当前的input中
    才进行数据的验证，鼠标离开input框，数据才进行验证
    
	事件，对于input进行的事件的定义
    鼠标离开input框,失去焦点  
	d.onblur=function(){
				console.log(d.value)
			}

	鼠标放到input中进行选择，获取焦点
    d.onfocus=function(){
				console.log(d.value)
			}
	失去焦点事件进行的数据的验证
    	d.onblur=function(){
				var v = d.value
				if(v=="admin"){
					m.innerText=("用户名已存在")
				}else{
					m.innerText=("用户名不存在，可以注册")
				}	
			}
	注册案例：
    	用户名
        密码
        ============》输入正确，正常注册，输入有误，不能注册
		<body>
		<form action="">
			用户名：<input type="text" name="username" id="uname" /><span id="msg"></span><br />
			密码：<input type="password" name="pwd" id="pwd" /><span id="msg1"></span><br />
			<input type="button" id="btn" value="注册" disabled="disabled" />
		</form>
		
		<script>
			var u = document.getElementById("uname")
			var p = document.getElementById("pwd")
			var b = document.getElementById("btn")
			var m = document.getElementById("msg")
			var m1 = document.getElementById("msg1")
			
			u.onblur=function(){
				if(u.value=="admin"){
					m.innerText="用户名输入正确"
				}else{
					m.innerText="用户名输入错误，重新输入"
				}
				if(pwdtest()&&usertest()){
						b.removeAttribute("disabled")
					}else{
						b.setAttribute("disabled","disabled")
					}
					
				
			}
			p.onblur=function(){
				if(p.value=="1234"){
					m1.innerText="密码输入正确"
				}else{
					m1.innerText="密码输入错误，重新输入"
				}
				if(pwdtest()&&usertest()){
						b.removeAttribute("disabled")
					}else{
						b.setAttribute("disabled","disabled")
					}
			}
			
			//验证用户名
			function usertest(){
				if(u.value=="admin"){
					return true;
				}else{
					return false;
				}
			}
			//验证密码
			function pwdtest(){
				if(p.value=="1234"){
					return true;
				}else{
					return false;
				}
			}
			b.onclick=function(){
				alert("注册成功")
			}	
		</script>
	</body>
    
  input中输入数据的事件，========》内容改变事件onchange
      var d = document.getElementById("data")
      d.onchange=function(){
          console.log(d.value)
      }
                
      只有input中的数据改变，才能进行事件的触发
      
    例如：买东西，地址的选择，使用内容改变事件，效果明显
    <form action="" id="fmt">
			<!--下拉条 数据选择-->
			省：<select id="sel">
				<option value="1">北京</option>
				<option value="2">上海</option>
				<option value="3">山西</option>
				<option value="4">河北</option>
			</select>
			市：<select id="city">
				
			</select>
			
		</form>

		<script>
			var s = document.getElementById("sel")
			var fs = document.getElementById("fmt")
			var citys = document.getElementById("city")
			s.onchange=function(){
				if(s.value=="1"){
					var o = document.createElement("option")
					o.innerText="北京市"
					o.setAttribute("value",1)
					citys.appendChild(o)
				}
			}
</script>
```

## 窗口中的事件

```js
<!--script如果放到head中，获取不到dom节点
			页面加载，有顺序的，从上到下加载
			先加载了script标签，获取到dom节点（html
			标签），此时，页面中标签还没有加载
			
			如果想要在head可以获取标签，等着页面加载页面中所有的标签
			后，在进行获取（标签在浏览器的窗口中进行的加载）
			
		-->
		<script>
			window.onload=function(){
				console.log(document.getElementById("di"))
			}
			-----------》一般script放到末尾，效率高
			
		</script>
	</head>
	<body>
		<div id="di"></div>
		
		
	</body>

案例：
	onload
	例如：网站，注册账号，分配了一个默认的头像，不喜欢，换一张图片
    ================================================》图片的预览
	<form action="">
			<input type="file" onchange="test(this)" />
			<img src="" id="im" alt="" width="100" height="100" />
	</form>
		<script>
		//source 对象信息
			var imgs = document.getElementById("im")
			function test(f){
				//f 当前的input标签，包含了当前图片
				var fi = (f.files[0])
				//当前的浏览器中进行显示
				//js 文件读取器
				var reader = new FileReader();
				reader.readAsDataURL(fi)
				console.log(reader)
				reader.onload=function(e){
					imgs.setAttribute("src",e.target.result)
				}
			}
			
			
		</script>

---------->图片，多张图，列举==============

常用事件
dom+事件

```

# day14

## bom对象

```js
bom 浏览器 object model
=====》浏览器对象
html 页面需要在浏览器中显示，html标签 js dom节点
bom 浏览器 html显示在浏览器中=====》浏览器中相关信息，通过对象进行的展示

=========》窗口对象  window

浏览器地址栏
	地址栏是浏览器中的一个对象，通过window对象获取的
   获取地址栏对象：
   console.log(window.location)   

 对象的信息：
 host: "127.0.0.1:8020"
hostname: "127.0.0.1"
href: "http://127.0.0.1:8020/html2115/index29.html"
origin: "http://127.0.0.1:8020"
pathname: "/html2115/index29.html"
port: "8020"
protocol: "http:"
以后不是只有a标签可以进行点击时，跳转页面，所有的标签都可以跳转

    <div id="di">jfkdjfkd</div>
    <script>
            var d = document.getElementById("di")
    d.onclick=function(){
        window.location.href="http://www.baidu.com"
        给href赋值，修改值
        不给href赋值，获取值
    }	
    </script>

2 弹窗对象
	在浏览器中以窗口的形式进行展示
   //方法，没有通过对象进行方法的调用
	//默认通过window对象进行的调用，window可以省略
     window.alert(1)
    console.log(window.parseInt("123"))
    console.log(window.Number(11)) 
	
	alert窗口对象，简单信息的提示
    复杂的对象，显示时，不能查看对象详细信息，简单数字，字符串，可以查看
    alert(window)
	console.log(window)

	//确认框，数据保护
    var r = confirm("是否要删除？")
    console.log(r)

	//带输入条的弹窗
    //获取输入条中的数据，数据是指定要输入的，继续左其他操作
    //数据输入有误，不能进行其他操作
    //方法返回值，如果输入了，点击确定，返回输入框中的数据
    //点击的是取消，返回的数据null
    var r = prompt("如果要删除，输入是，否则否")
    console.log(r)

3 屏幕信息
	screen 屏幕相关信息

4 数据存储对象（网站访问时，浏览器中进行了相关数据的存储）
	localstorage
    本地存储，存储在自己的电脑上，关闭浏览器数据存在，持久存储（存在于硬盘上）
    数据写到localstorage中的方式：
    //		存在于硬盘上的数据，只要不删除，就一直存在
	//		window.localStorage.setItem("test123","data123")
	//	给指定的key赋值
	//		window.localStorage.age=10
		window.localStorage['test']="fjdkfjkdf"
	数据可以存储，就可以进行获取，不是所有的数据都进行存在，有用的数据才进行存储
    不赋值，就相当于获取
		console.log(window.localStorage.age)
		console.log(window.localStorage['test'])
		console.log(window.localStorage.getItem("test123")
                    
    sessionstorage 临时存储，存在于内存中，只要浏览器关闭，数据不存在
	session 会话
   例如：
     两个人打电话
```

![session](C:\Users\Tly\Desktop\session.png)

```js
实现数据的存储和获取
//		window.sessionStorage.setItem("session","data")
		console.log(window.sessionStorage.getItem("session"))


5 定时器方法
	在规定的时间内，进行某个逻辑的执行
		//	定时器，1 时间 默认的单位毫秒  2 逻辑
		//setTimeout定时器，一次性定时器，执行一次
			/*window.setTimeout(function(){
				console.log(10)
			},10000)*/
		//setInterval 每隔指定的时间，执行指定的逻辑
			window.setInterval(function(){
				console.log(10)
			},1000)
定时器的操作：
		//setInterval 每隔指定的时间，执行指定的逻辑
			var d = document.getElementById("di")
			var i = 0;
			//定时器的返回值，代表就是定时器是页面中的第几个
			var r = window.setInterval(function(){
				i++
				d.innerText=i	
			},1000)
			
			console.log(r)
			d.onmouseover=function(){
				//定时器没有了  清空定时器
				clearInterval(r)
			}
			d.onmouseleave=function(){
				r = window.setInterval(function(){
				i++
				d.innerText=i	
			},1000)}
```

## 正则表达式

```js
数据是否满足指定的逻辑，需要使用正则进行数据格式的验证
<body>
		<input type="text" id="di" />
		<script>
			var d = document.getElementById("di")
			//正则对象，指定正则的格式
			//特殊的符号
			//^ 以什么开始
			//例如：手机号 以1开始的 
			// 第二位数字：3 5 6 7 8 9---》一个范围的数字，
			//数字没有连续性----》[] 表示一个范围
			//[3,5,6,7,8,9] ,[356789],[3|5|6|7|8|9]
			//3-11位 0-9数据范围----》连续的，有规律的
			//====》[0-9]
			//数据位数  {数字}====》前面的数据出现的次数
//			数据位数  {数字,数字}====》前面的数据出现的次数
			//数据最少出现几个，最多出现几个
			
			//数据的结束-----》$
			
			/*var reg = new RegExp("^1[3|5|6|7|8|9][0-9]{9}$");
			//测试数据是否满足指定的格式
			d.onblur=function(){
				console.log(reg.test(d.value))
			}*/
			
//			数据位数  {数字,数字}====》前面的数据出现的次数
			//数据最少出现几个，最多出现几个
			/*var reg = new RegExp("^[1-9][0-9]{5,12}$");
			//测试数据是否满足指定的格式
			d.onblur=function(){
				console.log(reg.test(d.value))
			}*/
			
			//a值的数据匹配
			//+ 至少有一个指定的字符
			//? 指定的字符有0个或者一个
			//* 任意多个的数据匹配
			//. 任意字符  如果要匹配的数据.数据值，加[]
			var reg = new RegExp("^a[.]$");
			//测试数据是否满足指定的格式
			d.onblur=function(){
				console.log(reg.test(d.value))
			}	
		</script>	
	</body>
-------------------》js中的正则表达式
					语言中的正则匹配的规则都是一致的
java 正则表达式
public static void main(String[] args) {
//        正则 字符串
        String str = "aaabbaabbbabbab";
        String[] bs = str.split("b+");
        for (String s:bs
             ) {
            System.out.println(s);
        }
        System.out.println(bs.length);

    	 System.out.println(str.replaceAll("b{3}", "X"));

    }
}
java中的正则表达式和js中的规则一致，
进行字符串格式匹配时，可以进行指定规则的数据匹配


mysql 正则表达式
没有指定具体条件的查询，
-- 查询 根据指定的规则进行数据匹配
-- =====》模糊查询，条件，不知道具体值

-- 姓张的同学的信息
select * from student where sname like '张%'

select* from student where sname regexp '^张'
=====================》使用正则进行数据的匹配

select* from student where sname regexp 'a?'
select* from student where sname regexp 'a+'
select* from student where sname regexp 'a{3}'


select* from student where sname like '张%'or sname like '李%'
select* from student where sname regexp '^张|李'

mysql中的正则表达式，和js正则规则相同的
mysql 正则进行数据的匹配，不适用匹配符进行操作

```

## 总结

```
1 java8 新特性
	lambda表达式
	书写规则，优势
	简化规则
	方法引用
	stream流 构成条件
	开始流 中间流  结束流
2 mysql数据库
	操作流程
	常用的sql语句 功能
	表 数据库
	数据类型  数字 字符串 日期
	根据存储数据选择合适的数据类型，约束
	不同的方法
	运算符 关键词
	数据不在一个表中，表连接
	索引，加快查询效率  explain
3 jdbc java操作数据库
	1 流程
	 jar包使用
	2 封装jdbc
	3 PreparedStatement 和Statement区别
	4 事务（mysql  支付 ）
	
4 前端内容 html+css+js
	html 页面中内容的展示
	=======》展示的内容是什么，选择合适的标签
	
	css 实现标签以指定的样式进行展示
	选择器  优先级
	常用的样式  背景  边框 字体的 文本
	盒模型  边距 
	页面布局
	浮动  弹性布局  
	定位
	3D 浏览器不是平面结构

	js 编程控制标签的效果
	语言基础
	常用的方法
	数组方法=====》
	对象表示
	一类事物 function  json=====》
	dom节点
	事件 执行的逻辑====》
	bom对象
	正则表达式
	=======》js java mysql
```









